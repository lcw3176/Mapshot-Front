[
  
  {
    "title": "DB 트랜잭션",
    "url": "/blog/posts/DB_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/",
    "categories": "DB",
    "tags": "",
    "date": "2023-12-15 00:00:00 +0900",
    





    
    "snippet": "트랜잭션정의한 번 질의가 실행되면 질의가 모두 수행되거나 모두 수행되지 않는, 작업 수행의 논리적 단위이다.다양한 상황에서 트랜잭션이라는 용어를 사용할 수 있지만 보통 데이터베이스와 관련하여 많이 사용한다.이 글 또한 데이터베이스의 트랜잭션을 다루려고 한다.사용 이유데이터의 부정합을 방지하고자 할 때 사용한다.보통 트랜잭션은 다른 트랜잭션과 동시에 작...",
    "content": "트랜잭션정의한 번 질의가 실행되면 질의가 모두 수행되거나 모두 수행되지 않는, 작업 수행의 논리적 단위이다.다양한 상황에서 트랜잭션이라는 용어를 사용할 수 있지만 보통 데이터베이스와 관련하여 많이 사용한다.이 글 또한 데이터베이스의 트랜잭션을 다루려고 한다.사용 이유데이터의 부정합을 방지하고자 할 때 사용한다.보통 트랜잭션은 다른 트랜잭션과 동시에 작업 내용이 겹치는 행위(수정, 삭제)을 최대한 방지하는데,만약 이런 행동을 허용한다면 의도치 않은 결과를 얻게 될 수 있다.특성원자성 (Atomicity)All or Nothing의 표본이다.작업 단위를 일부분만 실행하지 않는다는 뜻인데, 한 트랜잭션에 포함되어 있다면 모든 작업 내용이 반영되거나 롤백되어야 한다.일관성 (Consistency)트랜잭션 완료 시 일관적인 데이터베이스의 상태가 유지되어야 한다.트랜잭션이 완료되었는데 갑자기 int 타입이 varchar 타입등으로 변경되어서는 안된다는 의미이다.격리성 (Isolation)트랜잭션 수행 중 다른 트랜잭션이 끼어들지 못하도록 보장한다.서로의 작업에 최대한 간섭하지 않아야 하며, 각자의 행위가 서로 영향을 끼치지 않아야한다.지속성 (Durability)성공적으로 수행된 트랜잭션은 영원히 반영된다.데이터베이스에 commit 완료시 해당 상태는 다른 쿼리가 실행되기 전까지 보장되어야 한다.고립성 보장 방법다양한 락 기법들을 통해 고립성을 보장하고 있다.데이터를 읽거나 쓸 때는 문을 잠궈서 다른 트랜잭션이 접근하지 못하도록 고립성을 보장하고, 수행을 마치면 락을 해제하여 데이터를 다른 트랜잭션이 접근할 수 있도록 허용한다.데이터를 잠그는 행위는 보통 컬럼 단위로 진행된다.shared lock보통 읽기 락이라고 많이 불리며, 데이터를 읽을 때(read) 사용한다.같은 shared lock을 취득한 다른 트랜잭션들이 데이터에 접근해 정보를 읽을 수 있기 때문에공유라는 의미를 가진 share 키워드를 사용하는 듯 하다.하지만 아무리 같은 shared lock을 취득한 트랜잭션일지라도 데이터를 쓰는 행위는 불가능하다.다시 정리하자면 여러 트랜잭션이 읽을 수는 있지만 쓰기는 허용하지 않는다.exclusive_lock쓰기 락이라고 많이 불리고, 데이터를 쓸때(insert, update) 사용한다.‘배타적’이라는 exclusive의 단어 뜻 답게 다른 트랙잭션은 접근할 수 없으며,읽기 작업도 허용되지 않는다.정리하면 다른 트랜잭션이 읽을 수도 쓸 수도 없다. 접근을 허용하지 않는다.고립 수준트랜잭션의 조회 범위를 지정, 제한하는 것이며 고립 수준이 올라갈수록 데이터를 읽는 속도는 느려지지만 데이터 정합성의 문제는 조금씩 완화된다.아래의 고립 수준은 낮은 단계부터 기술되어있다.READ UNCOMMITTED리드 언커밋티드는 말 그대로 커밋 여부에 관계없이 값을 읽어올 수 있다.고립 수준에 따른 대표적인 문제 상황이 3가지가 존재하는데다른 트랜잭션에 의해 변경된 값을 읽어오는 더티 리드, 쿼리를 2번 실행하는데 다른 트랜잭션이 수정, 삭제하여 다른값을 읽어오는 논 리피터블 리드, 쿼리를 2번 실행하는데 없던 레코드가 튀어나오는 팬텀 리드 현상이 존재한다.리드 언커밋티드는 위의 3가지 상황이 모두 발생할 우려가 있다.READ COMMITTED리드 커밋티드는 커밋이 완료된 데이터만 읽을 수 있다.고로 다른 트랜잭션이 조작한 값을 도중에 읽어오는 더티 리드 현상은 발생하지 않지만 여전히 논 리피터블 리드, 팬텀 리드 현상은 발생할 소지가 존재한다.REPEATABLE READ리피터블 리드는 트랜잭션이 시작되기 전에 커밋된 내용만 조회할 수 있게 하는 수준이다.이게 무슨 말이냐면, 트랜잭션마다 고유의 id값이 존재하는데 이 값은 지속적으로 증가한다.데이터베이스 테이블을 정의할 때 auto increment를 건 상황이라고 생각하면 이해가 빠를 듯 하다.그래서 중간에 값이 수정되어도 해당 id값보다 큰 트랜잭션의 변경사항은 읽어오지 않기 때문에다른 트랜잭션이 수정, 삭제하여 다른값을 읽어오는 논 리피터블 리드 현상을 막을 수 있다.하지만 테이블 단위의 쿼리, select count(*) 과 같은 쿼리 실행시 집계되지 않았던 데이터가 잡히는 팬텀 리드 현상이 발생할 수 있다.SERIALIZABLE트랜잭션이 진행중이면 다른 트랜잭션에서의 모든 수정, 삭제, 삽입이 불가능하다.무적의 방법 같지만 너무 많은 퍼포먼스가 희생되므로 거의 사용되지 않는다.참고  내가 예전에 정리했던 자료들"
  },
  
  {
    "title": "쌩신입의 카카오뱅크 도전기",
    "url": "/blog/posts/%EC%8C%A9%EC%8B%A0%EC%9E%85%EC%9D%98_%EC%B9%B4%EC%B9%B4%EC%98%A4%EB%B1%85%ED%81%AC_%EB%8F%84%EC%A0%84%EA%B8%B0/",
    "categories": "ETC",
    "tags": "",
    "date": "2023-11-15 00:00:00 +0900",
    





    
    "snippet": "아쉬움을 보내기 위해결론부터 쓰면 마지막 임원면접에서 떨어졌다.며칠동안 정말 아쉬워서 잠도 제대로 못잤는데, 이제는 떨쳐내기 위해 이 글을 쓰면서 길다면 길었던 여정의 마침표를 찍어볼까 한다.글을 시작하기 전에 잠시 내 정보를 요약하자면, 관련 업계 경력은 전혀 없는 신입이고제지공장 생산직과 복싱장 코치로 일한 경험은 있다.그리고 내용을 어디까지 적어...",
    "content": "아쉬움을 보내기 위해결론부터 쓰면 마지막 임원면접에서 떨어졌다.며칠동안 정말 아쉬워서 잠도 제대로 못잤는데, 이제는 떨쳐내기 위해 이 글을 쓰면서 길다면 길었던 여정의 마침표를 찍어볼까 한다.글을 시작하기 전에 잠시 내 정보를 요약하자면, 관련 업계 경력은 전혀 없는 신입이고제지공장 생산직과 복싱장 코치로 일한 경험은 있다.그리고 내용을 어디까지 적어도 괜찮은지 모르겠어서, 일단은 그냥 겪었던 일 세부적으로 다 적고 나중에 뭔 일(?) 나면 수정할 수도 있다. 어차피 잡플래닛 같은 곳 봐도 뭐 다 적어놓던데 별일 없지 않을까 싶다.원서접수내가 지원한 공고는 서버개발자 - 기반기술 이라는 공고였다. 5년차 이하를 뽑는다길래 그러면 0년차도 포함(?) 아닌가 싶어서 넣었다. 은행이라는 제약이 있긴 하지만 그런걸 감안하고서라도 만약 잘 풀린다면 충분히 커리어를 쌓기에는 차고 넘치는 회사라고 생각했다.23년 8월 17일날 원서를 접수했고, 한동안 잊고 살았다.과제전형헬스가 끝난 어느 점심즈음, 문자와 이메일이 동시에 알람이 와 있는것을 보았다. 보통 이러면 좋은 시그널이다. 이제 이메일 제목만 봐도 합격인지 불합격인지 알 수 있는 능력이 생겼다. 보통 메일 제목에 이전 전형의 결과에 대한 내용만 있으면 보통 탈락메일이고, 이전 전형의 결과와 함께 다음 전형에 대한 안내문구가 있으면 당연히 합격이다.과제 기간은 5일정도 주어졌던 것 같고, 웬지 내용은 말하면 안될 것 같아서 적지는 않겠다. 하지만 굉장히 특이한 과제였던 것은 분명하다. 제출 10분 전까지 코드를 고치면서 끙끙댔던것 같다.1차 면접운이 좋게도 과제전형에 합격해서 1차 면접을 가게 되었다.면접 관련 안내메일이 왔고, 신기했던 건 오는 방법이랑 건물 찾는 방법까지 적혀있는 별도의 링크도 함께 줬다.이때 판교를 처음 가봤는데, 도착하자마자 자꾸 웃음이 나오더라. 개발 성지에 온 것 같아서 마냥 들떴던 것 같다. 멋있어서 한컷 찍었는데 요즘은 뉴스에 하도 자주 나와서 더 눈에 익었다.1시간 반 전쯤 도착해서 판교 구경도 하고, 로비에 앉아서 이것저것 정리하다가 면접 대기실로 발걸음을 향했다.면접 시작전에 구글 폼같은곳에 이름적고 뭘 체크를 했는데 뭔지 기억이 안난다. 기다리고 있다 보니 서류를 넣은 팀의 개발자분이 데리러 왔고 쫄래쫄래 따라갔다.갔더니 웬걸, 면접관만 8명이다. 신입이라 불안해서 이렇게 다 데리고 오신건지 원래 그런건지 모르겠다만 회의실이 거진 가득 찰 인원이었다.먼저 면접관으로 참여하신 분들의 소개를 해주시고, 내 소개를 이어 하면서 면접이 본격적으로 시작되었는데 이건 적어도 되겠지??먼저 과제에 대한 리뷰를 하며 시작되었다.과제 구현에 기술 선택지가 있었는데, 왜 해당 기술을 선택했는지부터 시작해서 코드 작성 기준, 로그 작성 기준, 패키지 분리 기준 등등 다양한 것을 물어보셨다.그 다음은 CS 파트로 넘어가게 되었다.static 함수 관련 질문, 해시 함수, DB 인덱스, 프로세스 스레드, try with resource, 스프링 네이티브 이미지 등등 인터넷에 검색하면 나오는 질문에 더해서 내 프로젝트와 관련된 cs 질문들을 받았다.중간중간 인성 관련 질문도 받았는데 뭐 이건 굳이 안적어도 될 것 같다. 인터넷에 검색하면 나오는 인사질문들이랑 크게 다르지 않다.그렇게 2시간의 면접이 끝났고, 1시간 더 보려고 하셨는데 회의실 다음 사용 예약이 꽉차서 시간조절을 하시다가 잘 되지 않아서 일단 마무리되었다.기술 질문들에 그렇게 매끄럽게 대답하지 못한 것 같아서 사실 별 기대도 없었다. 애초에 신입이 아직 올 수 있는 회사는 아니라고 생각했기에 별 생각없이 면접을 봐서 차라리 덜 떨었던 것 같다.2차 면접아무 기대도 없었다고 하면 거짓말일 것 같다.그래도 기대 수치가 5%였다고 한다면 저 메일을 받자마자 폭발적으로 증가하기 시작한 것 같다. 솔직히 저 고비만 넘기면 입사인데, 누가 기대를 안 할 수 있겠는가.임원면접은 화상면접이었고, 1차와 마찬가지로 나름 열심히 준비했지만 기대치와 비례하게 부담감과 긴장도 올라가서 그랬던걸까. 뭐 하나 제대로 대답한게 없는 것 같다.면접은 1시간정도 진행되었고, 예측 가능한 인사질문들이 나왔지만 예측 불가능한 형태로 바뀌어 나왔다. 예를 들면 ‘우리가 지원자를 뽑아야 되는 이유’ 같은 건 예상 질문에 많이 있지만, ‘우리가 지원자를 뽑아야 되는 3가지 이유’와 같은 식으로 변형되어 나왔다.마침표메일 제목 보자마자 알았다. 위에서 말했듯이 이전 전형의 결과에 대한 멘트만 존재한다면 보통 탈락이다.그렇게 3개월간의 전형은 씁쓸하게 끝났다. 마지막 고비에서 미끄러진 게 더 아쉽긴 하지만, 이 감정에 사로잡혀 있어봤자 뭐가 더 좋겠는가. 이젠 털어내야지.인생사 새옹지마, 더 좋은 일이 일어날거라 믿으며 살아가야지.참고  내 경험"
  },
  
  {
    "title": "클러스터, 논클러스터 인덱스",
    "url": "/blog/posts/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0_%EB%85%BC%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0_%EC%9D%B8%EB%8D%B1%EC%8A%A4/",
    "categories": "DB",
    "tags": "",
    "date": "2023-10-29 00:00:00 +0900",
    





    
    "snippet": "인덱스란?인덱스는 테이블의 컬럼을 색인화 함으로서 책의 목차와 유사한 기능을 제공한다.데이터를 정렬 후 별도의 메모리 공간에 저장하는데, 이 형태는 key, value 쌍으로 구성된다.인덱스를 저장하는 방식에도 종류가 있는데, 대표적으로 클러스터형 인덱스와 논클러스터형 인덱스로 구분할 수 있다.클러스터 인덱스클러스터 인덱스는 데이터를 순차적으로 재배열...",
    "content": "인덱스란?인덱스는 테이블의 컬럼을 색인화 함으로서 책의 목차와 유사한 기능을 제공한다.데이터를 정렬 후 별도의 메모리 공간에 저장하는데, 이 형태는 key, value 쌍으로 구성된다.인덱스를 저장하는 방식에도 종류가 있는데, 대표적으로 클러스터형 인덱스와 논클러스터형 인덱스로 구분할 수 있다.클러스터 인덱스클러스터 인덱스는 데이터를 순차적으로 재배열한다. 대표적으로 MySQL에 해당 방식이 기본적으로 사용되고 있다.primary key를 설정하면 해당 컬럼은 자동으로 클러스터드 인덱스가 구성되며,데이터 위치를 참조하는 포인터를 가지고 있다.이를 활용하여 실제 데이터를 가져오는 방식이다.별도의 데이터 페이지를 생성하는것이 아니라 실제 테이블을 참조하기 때문에검색 속도는 빠르지만, 신규 데이터를 중간에 입력하거나 삭제하는 경우 다시 테이블을 정렬해야 하기 때문에성능저하가 올 수 있다.논 클러스터 인덱스논클러스터 인덱스는 실제 테이블과 별개로 데이터 페이지가 존재하며, PostgreSQL이 해당 방식을 채택하고 있다.실제 테이블을 정렬하는 것이 아니기 때문에 데이터 추가, 삭제에 대해 클러스터 인덱스보다 영향이 적지만,데이터 페이지에서 검색하는 과정이 추가되었으므로 비교적 더 많은 I/O 작업이 수행될 수 있다.인덱스 vs 풀 테이블 스캔인덱스도 별도의 테이블을 생성해서 참조한다는 것을 확인할 수 있었다.그렇다면 인덱스 테이블을 참조하는 것과 그냥 테이블을 풀스캔 하는것은 왜 그렇게 퍼포먼스 차이가 나는 것일까?해외 사이트에서 간단한 예시가 보여서 가져와봤다.            id      name                  1      Matt              2      Dave              3      Andrew              4      Todd              5      Blake              6      Evan              7      Nick              8      Zack      다음과 같은 friends 테이블이 존재한다고 가정하고, 아래와 같은 쿼리를 실행한다고 해보자.SELECT * FROM friends WHERE name = 'Zack';풀스캔            name      탐색순서                  Matt      1              Dave      2              Andrew      3              Todd      4              Blake      5              Evan      6              Nick      7              Zack      8      Zack을 탐색하기 위해서는 Matt부터 순차적으로 이름을 비교해보아야 한다.Zack은 테이블의 가장 마지막에 위치하고 있기 때문에, 테이블을 처음부터 끝까지 스캔해야 알 수 있는 그야말로 최악의 성능을 보이게 될 것이다.지금은 데이터가 8개밖에 되지 않기 때문에 8번만 비교해보면 Zack을 찾을 수 있지만, 데이터의 양이 증가할수록 탐색해야 하는 범위는 비례하게 늘어날 수 밖에 없다.인덱스만약 이름을 기준으로 인덱스가 걸려있다면 어떤 방식으로 탐색이 가능할까?            name                  Andrew              Blake              Dave              Evan              Matt              Nick              Todd              Zack      데이터는 다음과 같이 정렬되어 있을 것이고, Zack은 동일하게 테이블의 가장 마지막에 위치하고 있다.하지만 차이점이 있다면, ‘정렬된 데이터’라는 보장이 있다는 것이다.데이터가 정렬되어 있기 때문에, 이분 탐색과 같은 방식을 사용할 수 있고, 검색 성능이 크게 향상될 수 있다.            name      탐색순서                  Andrew      1              Blake      1              Dave      1              Evan      1              Matt      1              Nick                     Todd                     Zack             전체 데이터의 중간쯤 되는 Matt와 먼저 비교를 해본다. Z와 비교해보았을 때 M은 더 앞에 있는 알파벳이므로 절반의 데이터를 소거할 수 있다.그러면 이제 남은 데이터로 다시 비교를 해보자.            name      탐색순서                  Andrew      1              Blake      1              Dave      1              Evan      1              Matt      1              Nick      2              Todd      2              Zack             남은 데이터의 중간인 Tood와 비교를 해보았다. Z와 비교해보았을 때 T 역시 더 앞에 있는 알파벳이므로 절반의 데이터를 소거한다.그러면 이제 남은 데이터는 Zack 뿐이다.            name      탐색순서                  Andrew      1              Blake      1              Dave      1              Evan      1              Matt      1              Nick      2              Todd      2              Zack      3      Zack은 언제나 동일하게 테이블상의 가장 마지막에 존재했지만, 인덱스 페이지에서는 3번만에 Zack을 탐색할 수 있었다.참고      코딩 시그널, 클러스터 인덱스와 넌클러스터 인덱스/ 개념 총정리, https://junghn.tistory.com/entry/DB-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%99%80-%EB%84%8C%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EA%B0%9C%EB%85%90-%EC%B4%9D%EC%A0%95%EB%A6%AC        웨지의 개발 블록, Mysql 인덱스 - 클러스티드 인덱스와 논클러스티드 인덱스 개념편 , https://sihyung92.oopy.io/database/mysql-index        MySQL,  Clustered and Secondary Indexes, https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html        DEV_GOLF, 클러스터링 인덱스 vs 논 클러스터링 인덱스, https://golf-dev.tistory.com/67        dataschool, Indexing, https://dataschool.com/sql-optimization/how-indexing-works/  "
  },
  
  {
    "title": "정렬 알고리즘",
    "url": "/blog/posts/%EC%A0%95%EB%A0%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/",
    "categories": "Language",
    "tags": "",
    "date": "2023-10-25 00:00:00 +0900",
    





    
    "snippet": "거품 정렬(Bubble Sort)public void bubbleSort(int[] arr) {    int temp = 0;        for(int i = 0; i &lt; arr.length; i++) {           for(int j= 1 ; j &lt; arr.length-i; j++) {            if(arr[j - 1] ...",
    "content": "거품 정렬(Bubble Sort)public void bubbleSort(int[] arr) {    int temp = 0;        for(int i = 0; i &lt; arr.length; i++) {           for(int j= 1 ; j &lt; arr.length-i; j++) {            if(arr[j - 1] &gt; arr[j]) {                             temp = arr[j - 1];                arr[j - 1] = arr[j];                arr[j] = temp;            }        }    }}인접한 두 데이터를 비교 후, 자리를 교환하며 정렬하는 알고리즘이다.보통 가장 처음 배우는 정렬 방법이기 때문에 익숙하기도 한데, 바로 옆에 데이터끼리 크기를 비교하며 swap을 해주는 알고리즘이다.시간복잡도는 최선, 평균, 최악 모두 시간복잡도가 O(n^2)으로 동일하다.선택 정렬(Selection Sort)public void selectionSort(int[] arr){    int minIndex, temp;    for(int i = 0; i &lt; arr.length - 1; i++){        minIndex = i;        for(int j = i + 1; j &lt; arr.length; j++){            if(arr[j] &lt; arr[minIndex]){                minIndex = j;            }        }        temp = arr[minIndex];        arr[minIndex] = arr[i];        arr[i] = temp;    }}선택 정렬은 순서에 맞춰서 어떤 데이터를 선택할지 정하는 알고리즘이다.자리는 이미 정해져있고, 그곳에 맞는 데이터를 찾는 알고리즘이며 다음과 같은 예시를 들 수 있다.오름차순으로 정렬하고, 크기가 5인 배열이 있다면 0번째 인덱스에는 가장 작은 값이 와야 할 것이다.그리고 1번째 인덱스에는 0번째 인덱스의 값보다 크고 나머지 값들보다는 작은 값이 와야 한다.즉, 정렬 기준에 따라 자리에 맞는 값을 찾아나가는 알고리즘이다.삽입 정렬(Insertion Sort)public void insertionSort(int[] arr){    for(int i = 1; i &lt; arr.length; i++){        int temp = arr[i];        int prev = i - 1;        while((prev &gt;= 0) &amp;&amp; (arr[prev] &gt; temp)){            arr[prev + 1] = arr[prev];            prev--;        }        arr[prev + 1] = temp;    }}바로 앞에 있는 데이터와 대소를 비교 후, 적당한 자리에서 데이터를 뒤로 밀고 지정된 자리에 자료를 삽입하는 알고리즘이다.오름차순 정렬 기준, 크기가 3인 배열이 있고 각 데이터의 값이 3,2,1 이라고 가정하고비교 인덱스는 1부터 시작하니 2의 값부터 진행해보자.&lt;!-- 첫번째 --&gt;3. [2], 1 -&gt; [2], 3, 1&lt;!-- 두번째 --&gt;2, 3, [1] -&gt; 2, [1], 3 -&gt; [1], 2, 3다음과 같이 정렬이 진행된다.시간복잡도는 평균과 최악(역정렬)의 경우는 O(n^2) 이며,하지만 모두 졍럴이 되어있는 최선의 경우는 O(n)을 가진다.병합 정렬(Merge Sort)public void mergeSort(int[] array, int left, int right) {        if(left &lt; right) {        int mid = (left + right) / 2;                mergeSort(array, left, mid);        mergeSort(array, mid+1, right);        merge(array, left, mid, right);    }    }public void merge(int[] array, int left, int mid, int right) {    int[] L = Arrays.copyOfRange(array, left, mid + 1);    int[] R = Arrays.copyOfRange(array, mid + 1, right + 1);        int i = 0, j = 0, k = left;    int leftLength = L.length;    int rightLength = R.length;        while(i &lt; leftLength &amp;&amp; j &lt; rightLength) {        if(L[i] &lt;= R[j]) {            array[k] = L[i++];        }        else {            array[k] = R[j++];        }        k++;    }        while(i &lt; leftLength) {        array[k++] = L[i++];    }    while(j &lt; rightLength) {        array[k++] = R[j++];    }}데이터를 두 개의 동일한 크기로 지속적 분할, 정렬 후 작은 단위의 데이터를 다시 합해가며 전체를 정렬하는 방법이다.데이터를 동일한 크기로 나누는 분할(divide), 나눈 데이터를 정렬하는 정복(conquer), 정렬된 작은 데이터를 다시 하나의 큰 데이터로 만드는 결합(combine)의 3단계로 이루어진다.퀵 정렬(Quick Sort)public void quickSort(int[] array, int left, int right) {    if(left &gt;= right) return;    int pivot = partition();         quickSort(array, left, pivot-1);     quickSort(array, pivot+1, right); }public int partition(int[] array, int left, int right) {    int pivot = array[left];     int i = left, j = right;        while(i &lt; j) {        while(pivot &lt; array[j]) {            j--;        }        while(i &lt; j &amp;&amp; pivot &gt;= array[i]){            i++;        }        swap(array, i, j);    }    array[left] = array[i];    array[i] = pivot;        return i;}퀵 정렬은 병합 정렬과 유사하지만 데이터를 비균등하게 분할한다는 차이가 있다.먼저 기준점이 될 데이터를 임의로 한개를 선별한다. 이를 피봇(pivot)이라고 칭한다.피봇을 기준으로 데이터를 나누는데, 오름차순 기준으로 왼쪽에는 피봇보다 작은 요소, 오른쪽에는 피봇보다 큰 요소로 나눈다.이 과정을 분할(divide)이라고 부른다.그리고 나누어진 데이터들을 지속적으로 정렬하는데 이를 정복(conquer) 단계라고 부른다.병합 정렬과 마찬가지로 정렬된 작은 데이터들을 하나의 큰 데이터로 다시 합치고, 이를 결합(combine) 단계라고 칭한다힙 정렬(Heap Sort)private void solve() {    int[] array = { 230, 10, 60, 550, 40, 220, 20 };     heapSort(array);     for (int v : array) {        System.out.println(v);    }} public void heapify(int array[], int n, int i) {    int p = i;    int l = i * 2 + 1;    int r = i * 2 + 2;     if (l &lt; n &amp;&amp; array[p] &lt; array[l]) {        p = l;    }     if (r &lt; n &amp;&amp; array[p] &lt; array[r]) {        p = r;    }     if (i != p) {        swap(array, p, i);        heapify(array, n, p);    }} public void heapSort(int[] array) {    int n = array.length;    for (int i = n / 2 - 1; i &gt;= 0; i--) {        heapify(array, n, i);    }     for (int i = n - 1; i &gt; 0; i--) {        swap(array, 0, i);        heapify(array, i, 0);    }} public void swap(int[] array, int a, int b) {    int temp = array[a];    array[a] = array[b];    array[b] = temp;}힙 자료구조를 기반으로한 정렬 방식이며, 힙은 왼쪽부터 노드가 순서대로 채워지고 서브트리의 갯수가 2개를 넘지 않는 완전 이진트리이다.자식 노드의 값과 부모 노드의 값을 비교하며 정렬하고, 조건에 맞게 부모노드와 자식노드의 값을 교체해주는 방식이다.참고  Gyuseok Kim, Tech Interview, https://gyoogle.dev/blog/algorithm/Bubble%20Sort.html  gmlwjd9405, 합병 정렬(merge sort)이란, https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html  gmlwjd9405, 퀵 정렬(quick sort)이란, https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html  gmlwjd9405, 힙 정렬(heap sort)이란, https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html"
  },
  
  {
    "title": "운영체제의 동기화 기법",
    "url": "/blog/posts/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98_%EB%8F%99%EA%B8%B0%ED%99%94_%EA%B8%B0%EB%B2%95/",
    "categories": "OS",
    "tags": "",
    "date": "2023-10-24 00:00:00 +0900",
    





    
    "snippet": "동기화란?  작업들 사이의 수행 시기를 맞추는 것. 사건이 동시에 일어나거나, 일정한 간격을 두고 일어나도록 시간의 간격을 조정하는 것을 이른다.-네이버 국어사전-국어사전에 따르면 ‘동기화’에 대해 위와 같이 설명하고 있다.컴퓨터 과학에서도 비슷한 의미로 통용되는데, 작업들의 수행 시기를 맞추면서 여러 프로세스가 공유하고 있는 자원이 일관되게 유지될 ...",
    "content": "동기화란?  작업들 사이의 수행 시기를 맞추는 것. 사건이 동시에 일어나거나, 일정한 간격을 두고 일어나도록 시간의 간격을 조정하는 것을 이른다.-네이버 국어사전-국어사전에 따르면 ‘동기화’에 대해 위와 같이 설명하고 있다.컴퓨터 과학에서도 비슷한 의미로 통용되는데, 작업들의 수행 시기를 맞추면서 여러 프로세스가 공유하고 있는 자원이 일관되게 유지될 수 있도록 하는 방법이다.동기화는 여러 프로세스가 접근하는 공유자원을 사용할 때 중요한 화두로 떠오르는데, 예기치 않은 데이터의 접근과 변경으로 다른 프로세스의 작동에 영향을 끼칠 수 있기 때문이다.이런 공유자원에 2개 이상의 프로세스가 접근해서 데이터를 조작하는 상황을 경쟁 상태(race condition)이라 하며, 프로세스의 접근 순서나 처리 속도에 따라 결과값에 영향을 줄 수 있다. 이는 다양한 동시성에 관련된 문제들을 야기한다.그래서 공유 자원 접근 순서에 따라 결과에 영향을 끼칠 수 있는 코드 블럭을 임계 영역(critical section)이라고 하며, 해당 구역에서 발생하는 문제들을 다루기 위해 다양한 동기화 기법들이 고안되었다.Mutex뮤텍스는 임계구역에서의 코드 실행을 서로 겹치지 않게, 각 스레드 or 프로세스가 단독으로 실행하게 하는 동기화 기법이다. 공유 자원에 대한 접근을 Locking, Unlocking을 사용해 조율하며,뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다.쉬운 예시로 화장실을 많이 드는 것 같다.음식점에서 공용 화장실을 이용할 때 우리는 가게에 있는 열쇠를 획득 후 간다. 다음 손님은 이전 손님이 공용 화장실에 대한 열쇠를 반납하기 전까지는 접근할 수 없다.즉, Lock에 대한 소유권이 Lock을 가진 사람에게 있다는 것이다.            종류      동시 실행 횟수      외부 락 해제                  Mutex      1      X      Semaphore세마포어와 뮤텍스의 결정적인 차이점은 동시에 실행가능한 프로세스 or 스레드의 갯수와 외부에서 lock을 해제할 수 있는지의 여부이다.세마포어는 다음과 같은 3가지의 값으로 상태를 제어한다.  initialize : 세마포어 초기화 (카운터 초기화)  decrement : 잠금 (카운터 감소)  increment : 해제 (카운터 증가)세마포어는 공용 화장실의 칸이 여러 개 있고, 노크를 해서 화장실을 이용하고 있는 손님을 밖으로 불러낼 수 있다는 점이 다르다.Lock에 대한 소유권이 Lock을 가진 사람뿐만 아니라 외부에도 있고, 동시에 여러 작업이 수행될 수 있다는 점이 Mutex와의 결정적인 차이점이다.위의 항목을 기억한다면 이진 세마포어와 뮤텍스는 차이가 있음을 발견할 수 있다.이진 세마포어는 카운터의 값이 1이라서 동시에 실행가능한 프로세스 or 스레드가 뮤텍스와 같이 1개뿐이지만, 세부적인 작동 사항에서는 약간 다르다는 것을 알 수 있다.            종류      동시 실행 횟수      외부 락 해제                  Mutex      1      X              Semaphore      N      O      참고      Splin, Operating System : 뮤텍스(Mutex) / 세마포어(Semaphore) / 모니터(Monitor), https://dev-splin.github.io/cs(computer%20science)/operating%20system/OS-Mutex,Semaphore,Monitor/        chappi, OS는 할껀데 핵심만 합니다. 8편 Critical section (임계 구역), https://velog.io/@chappi/OS%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A9%EB%8B%88%EB%8B%A4.-8%ED%8E%B8-Critical-section-%EC%9E%84%EA%B3%84-%EA%B5%AC%EC%97%AD  "
  },
  
  {
    "title": "ArrayList vs LinkedList",
    "url": "/blog/posts/ArrayList_vs_LinkedList/",
    "categories": "Language",
    "tags": "",
    "date": "2023-10-21 00:00:00 +0900",
    





    
    "snippet": "ArrayList란?ArrayList는 크기가 가변적으로 변하는 리스트이다. 일반적인 배열로 데이터를 다룰 때에는 처음 설정한 사이즈 그대로 다뤄야 한다는 불편함이 있지만, ArrayList는 데이터 크기에 따른 배열의 사이즈를 내부에서 자동으로 관리해준다.내부 구현생성자private static final Object[] EMPTY_ELEMENTDA...",
    "content": "ArrayList란?ArrayList는 크기가 가변적으로 변하는 리스트이다. 일반적인 배열로 데이터를 다룰 때에는 처음 설정한 사이즈 그대로 다뤄야 한다는 불편함이 있지만, ArrayList는 데이터 크기에 따른 배열의 사이즈를 내부에서 자동으로 관리해준다.내부 구현생성자private static final Object[] EMPTY_ELEMENTDATA = {};private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};// ...public ArrayList(int initialCapacity) {    if (initialCapacity &gt; 0) {        this.elementData = new Object[initialCapacity];    } else if (initialCapacity == 0) {        this.elementData = EMPTY_ELEMENTDATA;    } else {        throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity);    }}public ArrayList() {    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}public ArrayList(Collection&lt;? extends E&gt; c) {    Object[] a = c.toArray();    if ((size = a.length) != 0) {        if (c.getClass() == ArrayList.class) {            elementData = a;        } else {            elementData = Arrays.copyOf(a, size, Object[].class);        }    } else {        // replace with empty array.        elementData = EMPTY_ELEMENTDATA;    }}크기를 지정해서 생성해 줄 수 있으며, 별도로 지정하지 않으면 빈 배열로 초기화된다. 만약 다른 타입의 컬렉션을 매개변수로 넣어준다면 해당 값을 복사해서 저장한다.삽입(끝)public boolean add(E e) {    modCount++;    add(e, elementData, size);    return true;}private void add(E e, Object[] elementData, int s) {    if (s == elementData.length)        elementData = grow();    elementData[s] = e;    size = s + 1;}리스트의 맨 마지막에 데이터를 삽입할 경우 먼저 modCount를 증가시킨다.아마 modifyCount의 줄임말로 추측되는데, expectedModCount와 비교하며 데이터의 예상하지 않은수정 여부를 판별하는 변수이다.그리고 내부에 private 메서드로 정의된 add를 호출하는데, 만약 더 이상 데이터를 추가할 공간이 없다면 grow() 메서드를 통해 배열을 키우고 데이터를 저장한다.그렇다면 grow() 메서드는 어떻게 동작하는지 알아보자.private static final int DEFAULT_CAPACITY = 10;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;// ...private Object[] grow(int minCapacity) {    return elementData = Arrays.copyOf(elementData,                                    newCapacity(minCapacity));}private int newCapacity(int minCapacity) {           int oldCapacity = elementData.length;    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    if (newCapacity - minCapacity &lt;= 0) {        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)            return Math.max(DEFAULT_CAPACITY, minCapacity);        if (minCapacity &lt; 0) // overflow            throw new OutOfMemoryError();        return minCapacity;    }    return (newCapacity - MAX_ARRAY_SIZE &lt;= 0)        ? newCapacity        : hugeCapacity(minCapacity);}private static int hugeCapacity(int minCapacity) {    if (minCapacity &lt; 0)        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE)        ? Integer.MAX_VALUE        : MAX_ARRAY_SIZE;}기존 데이터를 복사하면서 배열 사이즈를 키우는데, 여기서 비트연산자가 사용된다.예를 들어 현재 내부 배열의 크기가 32라면 오른쪽 시프트 연산을 통해 16만큼의 공간을 추가한다.쉽게 생각하면 현재 크기의 절반만큼 새롭게 공간을 추가한다고 보면 될 것 같다.삽입(중간)public void add(int index, E element) {    rangeCheckForAdd(index);    modCount++;    final int s;    Object[] elementData;    if ((s = size) == (elementData = this.elementData).length)        elementData = grow();    System.arraycopy(elementData, index,                    elementData, index + 1,                    s - index);    elementData[index] = element;    size = s + 1;}arrayList의 중간에 데이터를 추가할 때 차이점이 있다면 매번 배열이 새롭게 복사된다는 점이다.맨 끝에 데이터를 추가할 때에는 현재 배열에 여유공간이 없을 때만 배열이 새로 생성되고, 공간이 있다면인덱스를 통한 빠른 추가가 가능했지만 중간에 데이터를 추가할 시 새로 추가된 자리 뒷쪽의 데이터는 전부 다 한칸씩위치를 뒤로 이동해주어야 하기 때문에 데이터 복사가 일어나고, 이는 성능에 악영향을 끼칠 수 있다.삭제public E remove(int index) {    Objects.checkIndex(index, size);    final Object[] es = elementData;    @SuppressWarnings(\"unchecked\") E oldValue = (E) es[index];    fastRemove(es, index);    return oldValue;}public boolean remove(Object o) {    final Object[] es = elementData;    final int size = this.size;    int i = 0;    found: {        if (o == null) {            for (; i &lt; size; i++)                if (es[i] == null)                    break found;        } else {            for (; i &lt; size; i++)                if (o.equals(es[i]))                    break found;        }        return false;    }    fastRemove(es, i);    return true;}// ...private void fastRemove(Object[] es, int i) {    modCount++;    final int newSize;    if ((newSize = size - 1) &gt; i)        System.arraycopy(es, i + 1, es, i, newSize - i);    es[size = newSize] = null;}데이터를 삭제하는 remove 메서드도 add와 비슷한 메카니즘으로 작동한다.해당 데이터를 제외한 범위로 새로 배열을 복사한다.탐색public E get(int index) {    Objects.checkIndex(index, size);    return elementData(index);}E elementData(int index) {    return (E) elementData[index];}// ...public int indexOf(Object o) {    return indexOfRange(o, 0, size);}int indexOfRange(Object o, int start, int end) {    Object[] es = elementData;    if (o == null) {        for (int i = start; i &lt; end; i++) {            if (es[i] == null) {                return i;            }        }    } else {        for (int i = start; i &lt; end; i++) {            if (o.equals(es[i])) {                return i;            }        }    }    return -1;}인덱스를 통해 빠르게 데이터에 접근, 값을 반환한다.특정 값에 해당하는 인덱스를 찾을때도 for문을 통해 배열을 빠르게 순회한다.LinkedList란?LinkedList 또한 데이터를 저장하는 리스트이다. 각각의 노드가 관련 데이터와 다음 노드에 대한 포인터를 가지고 있다.내부 구현생성자transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last;public LinkedList() {}public LinkedList(Collection&lt;? extends E&gt; c) {    this();    addAll(c);}// ..private static class Node&lt;E&gt; {    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {        this.item = element;        this.next = next;        this.prev = prev;    }}arrayList에 비하면 매우 단순하다.linkedList에서는 시작 노드와 마지막 노드에 대한 정보만 가지고 있고, 각각의 노드는 이전 노드와 다음 노드에 대한 정보를 가지고 있다.삽입(끝)public boolean add(E e) {    linkLast(e);    return true;}// ..void linkLast(E e) {    final Node&lt;E&gt; l = last;    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);    last = newNode;    if (l == null)        first = newNode;    else        l.next = newNode;    size++;    modCount++;}상황에 따라 노드를 배정한다.만약 현재 첫번째 노드에 대한 정보가 없다면 데이터가 추가되지 않은것이므로 첫번째 노드로 추가하고,정보가 존재한다면 linkedList가 관리하는 마지막 노드에 대한 정보를 교체해준다삽입(중간)public void add(int index, E element) {    checkPositionIndex(index);    if (index == size)        linkLast(element);    else        linkBefore(element, node(index));}Node&lt;E&gt; node(int index) {            if (index &lt; (size &gt;&gt; 1)) {        Node&lt;E&gt; x = first;        for (int i = 0; i &lt; index; i++)            x = x.next;        return x;    } else {        Node&lt;E&gt; x = last;        for (int i = size - 1; i &gt; index; i--)            x = x.prev;        return x;    }}void linkBefore(E e, Node&lt;E&gt; succ) {    // assert succ != null;    final Node&lt;E&gt; pred = succ.prev;    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);    succ.prev = newNode;    if (pred == null)        first = newNode;    else        pred.next = newNode;    size++;    modCount++;}이 과정은 arrayList에 비해 효과적인데, 데이터를 삽입하려는 인덱스의 노드를 찾은 후새로운 노드를 해당 노드를 바라보도록 포인터 정보만 교체해준다.arrayList는 인덱스 정보를 변경하기 위해 배열을 다시 배치하는 과정을 거쳤지만,linkedList는 보다 효과적으로 데이터 삽입을 하고 있다.삭제public boolean remove(Object o) {    if (o == null) {        for (Node&lt;E&gt; x = first; x != null; x = x.next) {            if (x.item == null) {                unlink(x);                return true;            }        }    } else {        for (Node&lt;E&gt; x = first; x != null; x = x.next) {            if (o.equals(x.item)) {                unlink(x);                return true;            }        }    }    return false;}E unlink(Node&lt;E&gt; x) {    final E element = x.item;    final Node&lt;E&gt; next = x.next;    final Node&lt;E&gt; prev = x.prev;    if (prev == null) {        first = next;    } else {        prev.next = next;        x.prev = null;    }    if (next == null) {        last = prev;    } else {        next.prev = prev;        x.next = null;    }    x.item = null;    size--;    modCount++;    return element;}해당 데이터의 참조를 끊은 후, 주변 데이터의 포인터를 다시 연결시켜주는 방식으로 작동하고 있다.탐색public E get(int index) {    checkElementIndex(index);    return node(index).item;}Node&lt;E&gt; node(int index) {            if (index &lt; (size &gt;&gt; 1)) {        Node&lt;E&gt; x = first;        for (int i = 0; i &lt; index; i++)            x = x.next;        return x;    } else {        Node&lt;E&gt; x = last;        for (int i = size - 1; i &gt; index; i--)            x = x.prev;        return x;    }}// ..public int indexOf(Object o) {    int index = 0;    if (o == null) {        for (Node&lt;E&gt; x = first; x != null; x = x.next) {            if (x.item == null)                return index;            index++;        }    } else {        for (Node&lt;E&gt; x = first; x != null; x = x.next) {            if (o.equals(x.item))                return index;            index++;        }    }    return -1;}for문을 이용, 다음 노드에 대한 정보를 탐색하며 데이터를 비교한다.arrayList는 배열이라는 선형적인 자료구조를 통해 빠른 접근이 가능했다면linkedList는 같은 for문이라도 메모리 여러군데에 흩어져있는 노드를 한 곳씩 모두 방문 후 다음노드를 찾아가야하기 때문에비교적 낮은 퍼포먼스를 보일 수 있다.참고      자바니또의 Tech선물, Iterator의 내부동작, https://brandpark.github.io/java/2021/01/24/iterator.html        인텔리제이를 통한 코드 참고  "
  },
  
  {
    "title": "자바 리플렉션",
    "url": "/blog/posts/%EC%9E%90%EB%B0%94_%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98/",
    "categories": "Language",
    "tags": "",
    "date": "2023-10-20 00:00:00 +0900",
    





    
    "snippet": "리플렉션이란?사전적 의미로는 ‘반사’라는 뜻을 가지고 있으며,자바에서는 런타임 단계에서 클래스, 메서드 등의 정보를 얻어오는 기술을 뜻한다. 연못에 형상이 반사되어 비치듯이, 투영된 클래스의 정보를 얻어온다는 의미로 이러한 이름이 붙은게 아닌가 싶다.리플렉션을 활용하는 대표적인 사례로는 Jackson과 같이 객체를 매핑해주는 라이브러리가 있다.리플렉션...",
    "content": "리플렉션이란?사전적 의미로는 ‘반사’라는 뜻을 가지고 있으며,자바에서는 런타임 단계에서 클래스, 메서드 등의 정보를 얻어오는 기술을 뜻한다. 연못에 형상이 반사되어 비치듯이, 투영된 클래스의 정보를 얻어온다는 의미로 이러한 이름이 붙은게 아닌가 싶다.리플렉션을 활용하는 대표적인 사례로는 Jackson과 같이 객체를 매핑해주는 라이브러리가 있다.리플렉션으로 클래스의 정보를 받아와 getter를 찾은 후 json 형식으로 변환해주는 등의 역할을 수행하고 있다.작동 원리먼저 자바 코드를 컴파일하고 바이트코드에 해당되는 .class 파일을 생성한다.그리고 클래스로더는 런타임동안 동적으로 클래스를 읽어온다.런타임에 동적으로 클래스를 로딩하기 위해서는 해당 클래스에 대한 정보를 읽어올 때 검증을 하기 위한 정보를 얻을 수단이 필요했다.만약 이런 유효성 검증 절차가 존재하지 않는다면 .class 파일의 버전 불일치 등 올바른 클래스를 가져왔는지 알 수 없는 문제가 발생한다.이를 해결하기 위해 jvm 내부에는 클래스 분석 기능이 존재하며, jdk 1.1부터는 자바 개발자 또한 리플렉션을 이용해 클래스의 분석을 할 수 있도록 하고 있다.네이티브 이미지와 리플렉션최근 GraalVM은 네이티브 이미지를 지원하기 시작했다.네이티브 이미지는 기존에 런타임 환경에서 JIT 컴파일러를 통해 작동하던 자바 코드를 바이너리 실행 파일로 ahead of time(미리) 컴파일하는 기술이다.기존 JIT(just-in-time) 컴파일러를 이용한 방식은 런타임 중에 컴파일을 수행하는 방식이었다.이러한 방식은 런타임 중에 지속적인 최적화를 수행하기 때문에 초기 구동 시 느린 부팅 속도 및 퍼포먼스 저하 이슈가 있었다.이를 극복하기 위해 AoT(ahead-of-time) 컴파일러가 탄생했다.AOT 컴파일러는 자바 바이트코드를 컴파일, 실행 파일을 만들어준다.이런 방식은 굉장히 빠른 첫 실행 속도를 자랑하지만 런타임 최적화가 진행되지 않고,정적으로 실행 파일을 생성하다보니 리플렉션과 같은 동적 기술에 많은 제약을 받게 되었다.참고      Hudi, 자바 리플렉션 (Reflection) 기초, https://hudi.blog/java-reflection/        Baeldung, Guide to Java Reflection, https://www.baeldung.com/java-reflection        호호맨, 리플렉션 (reflection) 개념 이해하기, https://ebabby.tistory.com/4        IBM Developer, JITServer - Optimize your Java cloud-native applications, https://developer.ibm.com/articles/jitserver-optimize-your-java-cloud-native-applications/        자바캔, 클래스로더 1, 동적인 클래스 로딩과 클래스로더, https://javacan.tistory.com/entry/1        망나니개발자, GraalVM이 제공하는 네이티브 이미지(Native Image), https://mangkyu.tistory.com/302  "
  },
  
  {
    "title": "static 이란?",
    "url": "/blog/posts/static%EC%9D%B4%EB%9E%80/",
    "categories": "Language",
    "tags": "",
    "date": "2023-10-15 00:00:00 +0900",
    





    
    "snippet": "static 이란?static은 정적으로 할당되는 변수, 함수, 클래스 등에 사용되는 키워드이다.전역으로 공유되는 고정된 변수나 메서드를 정의할 때 사용되며, 프로그램의 생성과 동시에 static 영역에 할당되고 프로그램이 종료될 때 까지 유지된다.사용 예시static 키워드 사용 시 개발자가 별도의 객채 생성 과정을 거치지 않고 변수를 사용할 수 있...",
    "content": "static 이란?static은 정적으로 할당되는 변수, 함수, 클래스 등에 사용되는 키워드이다.전역으로 공유되는 고정된 변수나 메서드를 정의할 때 사용되며, 프로그램의 생성과 동시에 static 영역에 할당되고 프로그램이 종료될 때 까지 유지된다.사용 예시static 키워드 사용 시 개발자가 별도의 객채 생성 과정을 거치지 않고 변수를 사용할 수 있다.class Hello {    public static final int good = 1;}class Bye {    public int good = 1;}public class main {    public static void main(String[] args) {        System.out.println(Hello.good);        // new를 통한 별도의 생성과정 없이 접근 가능        // 1        Bye bye = new Bye();        System.out.println(bye.good);        // static 키워드가 없다면 new를 통해 관련 클래스를 생성해줘야 접근 가능        // 1    }}이러한 방식은 이미 메모리에 존재하는 변수와 메서드를 사용하므로 빠른 속도로 작동한다.하지만 static 키워드가 붙은 메소드에서는 일반 멤버변수를 사용할 수 없다.class hi {    int good = 1;    public static void hello(){        System.out.println(good);  // 불가능           }}이는 둘의 생성 시점이 다르기 때문인데, static 키워드가 붙은 메소드는 인스턴스 생성 전부터 호출이 가능하지만static이 붙지 않은 멤버 변수는 인스턴스가 생성 전에는 존재하지 않는다. static 메소드 입장에서는 알 수 없는, 혹은 존재하지 않는 변수를 사용하라는 코드이니 당연히 작동하지 않는다.그래서 해당 코드는 컴파일 단계에서 막히게 된다.고로 클래스간에 지속적으로 공유해서 사용하는, 변하지 않는 변수나 멤버변수와 같은 인스턴스 변수를 사용하지 않는메서드 작성 시에 static 키워드를 사용하면 유용하다.static의 장점을 살려서 나온 디자인 패턴이 싱글톤 패턴이며, 프로그램에서 오로지 하나의 객체만 생성되어야 하는 곳에 주로 사용된다.public class Singleton {    private static class singleInstanceHolder {        private static final Singleton INSTACE = new Singleton();    }    public static Singleton getInstance(){        return singleInstanceHolder.INSTANCE;    }} 데이터베이스 호출 코드, 스프링의 빈 컨테이너 기본 전략 등이 싱글톤을 활용한 사례이다.모든 함수나 객체를 static으로 사용한다면?static이 만능 해결사는 아니기에 다음과 같은 상황을 고려할 필요가 있다.메모리 사용량모든 변수, 메서드를 static으로 정의할 경우 불필요한 메모리 사용량이 증가할 수 있다.new 를 통해 생성된 객체들은 GC를 통해 사용하지 않을 경우 해제될 수 있지만, static으로 정의된 자원들은프로그램이 종료될 때 까지 유지되기 때문에 필요한 곳에만 사용해야 한다.다중 스레드 환경다중 스레드 환경에서의 안정성 또한 고려하여야 한다.만약 final, const 등과 같이 불변 키워드 변수라면 크게 상관없을 수도 있지만,값이 변할수 있는 가변적인 환경이라면 문제의 소지가 있다.여러 스레드에서 각자 상태에 맞게 값을 변경한다면 기대하지 않았던 동작을 할 수 있고,이는 에러의 소지가 다분한 코드가 된다.class Value {    public static boolean available = true;}class Process {    public void work(){        while(!Value.available){            // wait...        }        Value.available = false;        // dosomething()...        Value.available = true;            }}위의 코드에서 work() 메소드가 단일 스레드로 한번씩 처리될 때는 큰 문제가 없을 수 있지만,여러 스레드에서 동시에 해당 메소드에 진입해서 작업한다면 이후 동작은 예측하기 힘들어지게 된다.참고  Vaert Street, Static 키워드 바로 알고 사용하자, https://vaert.tistory.com/101  점프 투 자바, 07-03 스태틱, https://wikidocs.net/228  Baeldung, A Guide to the Static Keyword in Java, https://www.baeldung.com/java-static  JOINC, static 키워드, https://www.joinc.co.kr/w/man/12/static"
  },
  
  {
    "title": "자바의 try with resources",
    "url": "/blog/posts/try_with_resources/",
    "categories": "Language",
    "tags": "",
    "date": "2023-10-15 00:00:00 +0900",
    





    
    "snippet": "try with resources 란?try with resources는 자원 반납 코드를 자동으로 실행되도록 지원해주는 문법이다.파이썬에서는 with, C#에서는 using과 같은 유사한 문법이 존재한다.기존 방식 (try-catch-finally)문제점public static void main(String args[]) {        FileIn...",
    "content": "try with resources 란?try with resources는 자원 반납 코드를 자동으로 실행되도록 지원해주는 문법이다.파이썬에서는 with, C#에서는 using과 같은 유사한 문법이 존재한다.기존 방식 (try-catch-finally)문제점public static void main(String args[]) {        FileInputStream is = null;    BufferedInputStream bis = null;    try {        is = new FileInputStream(\"test.txt\");        bis = new BufferedInputStream(is);        // 처리...    } catch(Exception e){        log.info(\"에러\", e);    } finally {        try{            if (is != null) {                is.close();            }            if (bis != null){                bis.close();            }         } catch(Exception e) {            log.info(\"에러\", e);        }    }}기존 방식에서는 null 체크, close() 등의 자원 반납 함수를 직접 호출해야했다.이러한 방식은 자원 반납 코드를 추가해야하고, 실수로 자원을 반납하지 않거나 자원 반납 코드에서 에러 발생 시 대처가 힘든 경우 등의 문제점이 존재했다.이러한 문제점들을 해결하기 위해 try-with-resources 문법이 등장하게 되었다.새로운 방식 (try-with-resources)public static void main(String args[]) {    try (FileInputStream is = new FileInputStream(\"test.txt\");         BufferedInputStream bis = new BufferedInputStream(is)) {        // 처리...    } catch(Exception e) {        log.info(\"에러\", e);    }}해당 문법을 통해 조금 더 직관적으로 파일스트림에서 발생하는에러에 대처할 수 있는 코드를 작성할 수 있다.구현 조건AutoCloseablepublic interface AutoCloseable {    void close() throws Exception;}AutoCloseable 인터페이스를 구현해야한다.해당 인터페이스의 close() 메서드를 구현해주지 않으면 try-with-resources를 활용해서 자원 해제가 불가능하다.참고  망나니개발자, try-with-resources란? try-with-resources 사용법 예시와 try-with-resources를 사용해야 하는 이유, https://mangkyu.tistory.com/217  인파, 자바 Try With Resource 예외 처리, https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC-Try-With-Resource-%EB%AC%B8%EB%B2%95"
  },
  
  {
    "title": "해시 함수",
    "url": "/blog/posts/%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98/",
    "categories": "Language",
    "tags": "",
    "date": "2023-10-13 00:00:00 +0900",
    





    
    "snippet": "해시 함수란?private void hash(int x){    return x % 5;}hash(7);// 2hash(8);// 3hash(9);// 4해시 함수는 입력값을 고정된 길이의 특정 값으로 출력하는 함수이다. 출력 데이터인 해시값은 동일한 입력에는 항상 동일한 값을 리턴한다.모듈러 연산(나머지 계산)이 대표적인 예시로, 입력값을 나눈 나머...",
    "content": "해시 함수란?private void hash(int x){    return x % 5;}hash(7);// 2hash(8);// 3hash(9);// 4해시 함수는 입력값을 고정된 길이의 특정 값으로 출력하는 함수이다. 출력 데이터인 해시값은 동일한 입력에는 항상 동일한 값을 리턴한다.모듈러 연산(나머지 계산)이 대표적인 예시로, 입력값을 나눈 나머지 계산을 해시 함수로 활용하고,데이터셋은 0부터 나눈 숫자 미만까지 고정된 범위의 해시값으로 변환된다.특징단방향성, 결정론적해시 함수는 입력 값을 해시값으로 변환은 쉽지만, 해시값에서 원래의 값으로 되돌리는 것은 거의 불가능하다.또한 해시 함수는 같은 데이터 입력 시 항상 동일한 결과, 일정한 길이의 결과값을 리턴해야 한다.따라서 해시함수를 거친 두 개의 값이 다르다면 해당 값에 대한 원래 데이터 또한 다름을 보장할 수 있어야 한다.하지만 서로 다른 입력이 동일한 해시 값을 가질 수는 있으며, 이를 해시 충돌이라고 한다.이런 해시함수의 특징으로 인해 보안, 데이터 무결성 검증 등에 사용되고 있다.우리가 게임을 할 때 사용하는 플랫폼인 스팀에서 파일에 대한 변조가 일어났는지 확인을 할때 무결성 검사를 하는데,이런 대용량 데이터에 대해서 변조 여부를 확인할 때 사용하기 좋은 방식이 해시값을 이용한 비교이다.해시 충돌private void hash(int x){    return x % 5;}hash(7);// 2hash(12);// 2해시 함수에 서로 다른 입력을 넣었는데 동일한 해시값 출력시 해시 충돌이 발생했다고 한다.좋은 해시함수는 충돌 확률을 매우 낮게 최소화해야 하며, 이러한 요소를 평가하는 척도를 충돌 저항성이라고 한다.충돌 저항성이 좋다는 것은 해시 함수에 무작위로 데이터를 넣었을 때 결과값이 같은, 해시 함수가 충돌하는 다른 두 개의 입력값을발견하기 어렵다는 것을 의미한다.종류해시 테이블해시 테이블은 Key, Value 쌍으로 데이터를 저장하는 자료구조이다.키값을 해싱하여 빠른 속도로 해당되는 값을 탐색할 수 있으며, 평균 시간 복잡도는 O(1) 이다.만약 데이터 충돌 발생 시 버킷에 추가적으로 연결된 리스트로 검색 범위가 확대되므로 O(N)으로 시간 복잡도가 증가할 수 있다.MD5128비트 암호화 해시 함수이다. 주로 프로그램이나 파일이 원본 그대로인지를 확인하는 무결성 검사 등에 사용된다.하지만 몇 가지 암호화 결함들이 지속적으로 발견되기 시작했고,심지어 노트북 컴퓨터 한 대의 계산 능력으로 1분 내에 해시 충돌을 찾을 정도의 결함이 발견되기도 하면서 보안 관련 용도로 해당 알고리즘을 사용하는 것은 권장하지 않는다고 한다.SHA 256미국 국가안보국(NSA)의 설계에서 시작된 해시함수로, 256비트의 고정된 결과값, 64자리의 문자열을 반환한다. 2^256에 해당하는 경우의 수를 만들수 있어서 해시 충돌로부터 비교적 안전하다.출력속도가 다른 암호화 알고리즘과 비교해 빠르다는 장점이 있기 때문에 인증서, 블록체인 등에 많이 사용되고 있다.참고      코드스테이츠, 블록체인 해시함수 정의, 특징, 블록체인 활용 예시, https://www.codestates.com/blog/content/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98        해시넷, 해시함수, http://wiki.hash.kr/index.php/%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98        위키백과, 해시 함수, https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98        위키백과, 해시 테이블, https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%85%8C%EC%9D%B4%EB%B8%94        망나니개발자, 자료구조 해시테이블(HashTable)이란?, https://mangkyu.tistory.com/102        위키백과, MD5, https://ko.wikipedia.org/wiki/MD5        해시넷, SHA256, http://wiki.hash.kr/index.php/SHA256  "
  },
  
  {
    "title": "자바 병렬 스트림",
    "url": "/blog/posts/%EC%9E%90%EB%B0%94_%EB%B3%91%EB%A0%AC_%EC%8A%A4%ED%8A%B8%EB%A6%BC/",
    "categories": "Language",
    "tags": "",
    "date": "2023-10-08 00:00:00 +0900",
    





    
    "snippet": "서론병렬 처리란 CPU의 멀티 코어를 활용, 작업의 요소를 분할해서 각각의 코어가 처리하는 것을 말한다.Java 8부터 Stream API가 도입되었고, 해당 기능을 이용해 손쉽게 병렬 처리를 구현 가능하다.병렬 처리가 더 많은 코어를 활용하기 때문에 항상 빠르다고 생각할 수도 있으나 그렇지는 않다.병럴성데이터 병렬성데이터를 분할해서 여러 데이터셋을 ...",
    "content": "서론병렬 처리란 CPU의 멀티 코어를 활용, 작업의 요소를 분할해서 각각의 코어가 처리하는 것을 말한다.Java 8부터 Stream API가 도입되었고, 해당 기능을 이용해 손쉽게 병렬 처리를 구현 가능하다.병렬 처리가 더 많은 코어를 활용하기 때문에 항상 빠르다고 생각할 수도 있으나 그렇지는 않다.병럴성데이터 병렬성데이터를 분할해서 여러 데이터셋을 만들고 해당 데이터를 병렬 처리한다.자바의 병렬 스트림이 이에 해당된다.작업 병렬성서로 다른 작업을 병렬 처리하는것을 말한다. 대표적인 예로는 톰캣과 같은 WAS가 있으며, 클라이언트가 요청을 보내면 개별 스레드로 작업을 병렬적으로 처리한다.작업 방식포크조인 프레임워크병렬 스트림은 요소 처리를 위해 FORK 단계에서 내부적으로 데이터를 적당한 크기로 분할 후 연산 과정을 거친다.JOIN 단계에서는 연산의 결과들을 조합해서 최종적인 결과물을 산출해낸다.포크조인 프레임워크는 ExecutorService의 구현 객체인 ForkJoinPool을 사용해서 작업하는 스레드를 관리한다.고려할 사항들요소의 수와 요소당 처리 시간만약 처리할 요소가 작거나 요소당 필요한 연산량이 작다면 일반 스트림 사용을 고려해 보아야 한다.병렬 처리는 작업을 분할하고 다시 합치는 포크조인 단계가 있고, 스레드풀을 생성해야 하기 때문에병렬 스트림 사용시 오히려 잦은 컨텍스트 스위칭과 이로 인한 오버헤드로 퍼포먼스가 저하될 수 있다.스트림 소스의 종류배열을 사용하거나 ArrayList 같은 경우는 인덱스로 내부 데이터에 순차적인 접근이 가능하기 때문에요소를 쉽게 분리할 수 있으나, LinkedList처럼 다음 노드를 타고 가야 탐색이 되는 구조이거나 Map과 같이 순차적인 자료 구조가 아닐 경우 요소 분리가 쉽지 않기 때문에 속도가 저하될 수 있다.코어의 수증가한 스레드를 원할하게 처리할 만큼 CPU 코어의 숫자가 많지 않을 경우는 일반 스트림 사용을 고려해 보아야 한다.참고  한빛미디어, [자바 기초 강의] 171강. 17.13 요소 병렬 처리, https://www.youtube.com/watch?v=X2y_BL1TNPI  Baeldung, When to Use a Parallel Stream in Java, https://www.baeldung.com/java-when-to-use-parallel-stream"
  },
  
  {
    "title": "JVM 내부구조",
    "url": "/blog/posts/JVM_%EB%82%B4%EB%B6%80%EA%B5%AC%EC%A1%B0/",
    "categories": "Language",
    "tags": "",
    "date": "2023-10-04 00:00:00 +0900",
    





    
    "snippet": "데이터 타입원시 타입byte8비트의 정수 자료형, 기본값은 0이며 -128 ~ 127의 범위를 가진다.short16비트의 정수, 기본값은 0이며 -32768 ~ 32767의 범위를 가진다.int32비트의 정수, 기본값은 0이며 -2147483648 ~ 2147483647의 범위를 가진다.long64비트의 정수, 기본값은 0이며 9223372036854...",
    "content": "데이터 타입원시 타입byte8비트의 정수 자료형, 기본값은 0이며 -128 ~ 127의 범위를 가진다.short16비트의 정수, 기본값은 0이며 -32768 ~ 32767의 범위를 가진다.int32비트의 정수, 기본값은 0이며 -2147483648 ~ 2147483647의 범위를 가진다.long64비트의 정수, 기본값은 0이며 9223372036854775808 ~ 9223372036854775807의 범위를 가진다.char16비트의 문자, 16비트의 부호 없는 정수로 나타내고 UTF-16으로 인코딩되며 기본값은 null(‘\\u0000’)이다. 0 ~ 65535의 범위를 가진다float32비트의 부동 소수점, 기본값은 양수 0이다double64비트의 부동 소수점, 기본값은 양수 0이다.returnAddressJVM 명령어의 opcode에 대한 포인터이다. 일반적인 자바로 실행되는 프로그램을 개발하는 개발자가 직접 다룰일은 많지 않을 것 같다.booleanboolean 유형은 애매한게 정의는 되어 있지만 JVM 내부에 별도로 지원하는 명령어는 존재하지 않아 제한적으로 제공된다고 한다.내부적으로는 int 자료형을 사용해서 컴파일된다고 한다.참조 타입참조 타입에는 클래스, 배열, 인터페이스가 존재한다고 한다.런타임 데이터 영역JVM 프로그램 실행 중에 사용되는 영역이다. 일부는 JVM 시작 시 생성되고 JVM이 종료될 때만 삭제되며, 그 외에는 스레드별로 관리된다. 스레드별 데이터 영역은 스레드가 생성될 때 생성되고 스레드가 종료되면 소멸된다.PC 레지스터, JVM 스택, 네이티브 메소드 스택은 스레드별로 생성되며힙, 메소드영역, 런타임 상수풀은 스레드끼리 공유할 수 있다.스레드별 영역pc 레지스터JVM은 다중 스레드를 지원한다. JVM의 각 스레드에는 자체 pc(프로그램 카운터) 레지스터가 존재하며, JVM의 스레드는 해당 스레드에 대한 메서드를 실행하는데,  해당 메소드가 네이티브가 아닌 경우 pc 레지스터에는 현재 실행 중인 JVM의 명령어의 주소를 포함시킨다. 현재 스레드가 실행 중인 메소드가 네이티브이면 JVM의 pc 레지스터 값은 정의되지 않는다.라는 문서의 내용을 추측해보면 아마 자바를 통해서 실행하는 메소드가 아닌, 다른 프로세스의 메서드를 호출할 경우를 말하는 듯 하다.JVM 스택각각의 JVM 스레드는 생성 시 JVM 스택이 같이 생성된다. JVM 스택은 프레임을 저장하며(차후 설명), JVM 스택은 C와 같은 기존 언어의 스택과 유사하다. JVM 스택은 푸시 및 팝 프레임을 제외하고는 직접 조작되지 않으므로 프레임이 힙에 할당될 수 있으며, JVM 스택의 메모리는 연속적일 필요가 없다.JVM 스택은 고정된 크기일수도, 동적으로 확장 및 축소될 수도 있지만다음과 같은 상황에는 예외를 던질 수 있다.  스레드에 할당된 용량보다 더 큰 JVM 스택 용량이 필요한 경우 JVM은 StackOverflowError를 발생시킨다  JVM 스택이 동적으로 확장을 시도했지만 메모리가 부족하거나, 새로 스레드를 생성하며 JVM 스택 생성을 해야하는데 메모리가 부족한 경우 OutOfMemoryError 에러를 발생시킨다.네이티브 메서드 스택자바 외에 언어로 작성된 메소드 지원하기 위해 존재하는 공간이다. 역시나 크기는 가변적이다.이런 상황에서는 예외가 발생한다.  스레드 계산에 허용된 것보다 더 큰 메소드 스택이 필요한 경우 StackOverflowError 던짐.  크기 조절 시 가용 메모리가 부족한 경우 or 스레드 생성 시 초기 네이티브 메서드 스택 생성에 필요한 메모리가 부족한 경우 OutOfMemoryError 발생.공통 영역힙 영역JVM의 모든 스레드 간에 공유되는 공간이며, 모든 클래스 인스턴스 및 배열이 할당되는 런타임 데이터 영역이다.힙은 가상 머신 시작 시 생성되고 객체들을 명시적으로 할당 or 해제 할 수 없으며 가비지 컬렉터에 의해 회수된다. 힙 역시 고정된 크기일수도, 동적으로 확장 및 축소될 수 있다. 힙에 대한 메모리 또한 연속적일 필요는 없다.다음과 같은 상황에는 예외를 발생시킨다.  JVM 연산에 현재 할당된 메모리 용량보다 더 많은 힙이 필요한 경우 OutOfMemoryError 에러를 던진다.메소드 영역메소드 영역 또한 모든 스레드 간에 공유되는 영역이다.런타임 상수 풀, 필드 및 메서드 데이터 등 클래스의 메서드 및 생성자에 대한 코드를 저장한다.JVM 시작 시 생성되며 힙의 일부이지만 소규모의 프로젝트에서는 GC의 대상에서 제외시키는 방법도 있다고 한다. 메소드 영역도 고정된 크기이거나 필요한 대로 확장 및 축소될 수 있다. 메소드 영역의 메모리도 연속적일 필요는 없습니다.다음과 같은 상황에서는 예외를 발생시킨다.  데이터를 올리기에 메소드 영역의 메모리가 충분치 않을 때 OutOfMemoryError 발생.런타임 상수 풀런타임 상수 풀(constant pool)은 컴파일 타임에 감지된 숫자 리터럴, 런타임 동안 작동하는 메서드 및 필드에 대한 참조 등등 여러 종류의 상수가 포함된다.JVM의 메서드 영역에 포함되며 클래스 또는 인터페이스가 생성될 때 구성된다.다음과 같은 상황에서는 예외가 발생한다.  클래스나 인터페이스 생성 시 런타임 상수 풀 구성에 필요한 메모리가 JVM의 메서드 영역에서 사용할 수 있는 것보다 더 많은 메모리가 필요한 경우 OutOfMemoryError 발생.프레임프레임은 데이터 및 진행중인 연산의 결과를 저장하거나 메서드에 대한 값을 반환하며 예외를 전달하는 데 사용된다.메소드가 호출될 때마다 새 프레임이 생성되며, 실행 결과가 정상적이든 망했든 관계없이 메서드 호출이 완료되면 프레임은 삭제된다. 프레임은 JVM 스택에 할당되며, 각 프레임에는 자체 지역 변수 배열, 자체 피연산자 스택 및 현재 실행중인 메서드가 속해있는 클래스의 런타임 상수 풀에 대한 참조가 있다고 한다.실행중인 메서드가 다른 메서드를 호출하면 새 프레임이 생성되고 이것이 현재 프레임으로 설정된다. 메서드 반환 시 현재 프레임은 메서드 호출 결과를 이전 프레임으로 다시 전달하고, 쓸모가 없어진 프레임은 삭제된다.프레임은 스레드별로 할당되기 때문에 다른 스레드에서 참조할 수 없다.예외JVM의 예외는 Throwable 클래스의 인스턴스 or 해당 하위 클래스 중 하나이며, 다음과 같은 세 가지 이유 중 하나에 포함되면 예외를 발생시킨다.1. throw로 던지기2. JVM이 비정상적인 실행 조건 감지 시 발생  잘못된 명령이 실행될 경우 (ex: 배열 범위를 벗어나는 인덱싱)  프로그램의 일부를 로딩하거나 링크하는데 오류가 발생한 경우  메모리 사용량이 너무 과다할경우3. JVM 내부 오류 감지 시 예외 발생참고  Oracle, Chapter 2. The Structure of the Java Virtual Machine, https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-2.html"
  },
  
  {
    "title": "객체지향의 특징, 설계 원칙",
    "url": "/blog/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98_%ED%8A%B9%EC%A7%95,%EC%9B%90%EC%B9%99/",
    "categories": "Language",
    "tags": "",
    "date": "2023-10-01 00:00:00 +0900",
    





    
    "snippet": "개론어딘가에 갔을 때 그곳의 문화, 풍습에 맞게 행동하라는 말을 비유적으로 할 때 ‘로마에 가면 로마법을 따르라’ 라는 글귀를 언급하곤 한다.그렇다면 우리는 객체지향의 세계에 입문했다면, 무조건 객체지향의 원칙들을 지켜야 하는 것일까?물론 반드시 지킬 필요는 없다. 범법행위도 아니라서 잡혀갈 일도 없다.그런데 왜 우리는 객체지향의 원칙들을 공부하는 것...",
    "content": "개론어딘가에 갔을 때 그곳의 문화, 풍습에 맞게 행동하라는 말을 비유적으로 할 때 ‘로마에 가면 로마법을 따르라’ 라는 글귀를 언급하곤 한다.그렇다면 우리는 객체지향의 세계에 입문했다면, 무조건 객체지향의 원칙들을 지켜야 하는 것일까?물론 반드시 지킬 필요는 없다. 범법행위도 아니라서 잡혀갈 일도 없다.그런데 왜 우리는 객체지향의 원칙들을 공부하는 것일까?‘원칙’이라는 명칭이 붙은 이론이 있다면, 이미 널리 통용되고 검증되어 있을 가능성이 매우 높다.활자의 발명으로 인해 선조들의 시행착오를 전수받을수 있었듯이, 우리의 선배 개발자들도 이러한 이론들을 후배들에게 남기면서 더 좋은 설계, 개발 방법에 대한 지름길을 제시하는 것이라 생각한다.때로는 탄생 배경의 발자취를 그대로 따라가보는 것이 더 효과적인 방법이 될 수 있지만,모든 이론을 그렇게 학습하다가는 우리가 후대에게 물려줄 것들은 그저 선대의 유산뿐일수 있다.객체지향의 4가지 특징추상화어떠한 자료나 시스템 등으로부터 핵심적이거나 공통적인 개념, 기능을 간추려 내는 것을 말한다.일상 속에서 대표적인 추상화의 대표적인 예시로는 지하철 노선도가 있다.지하철 노선도와 실제 지도상의 역 배치는 매우 다른 형태이다.하지만 우리가 노선도를 통해 얻고자 하는 정보는 어느 역에서 환승을 해야 하는지, 몇 정거장을 더 가야하는지 등의 정보이지정확한 서울 지도상의 지하철 배치를 보고자 하는 것이 아니다.추상화는 이처럼 불필요한 부분들을 간소화하고, 중요한 속성들에 집중하는 과정이다.캡슐화class 감기약 implements 약 {    // 노출되는 부분    public void 사용하기(){        물과함께삼키기();    }    // 내부 구현, 외부에서는 접근할 수 없다    private void 물과함께삼키기(){    }}class 바르는약 implements 약 {    // 노출되는 부분    public void 사용하기(){        상처부위에_바르기();    }    // 내부 구현, 외부에서는 접근할 수 없다    private void 상처부위에_바르기(){    }}캡슐화란 클래스 내부의 속성과 기능들을 은닉해 외부로부터 보호하는 것을 말한다.우리가 병원에서 처방받은 캡슐 알약을 생각해보면 이해가 쉽다.우리는 처방받은 약을 ‘먹는다’는 행위만 할 뿐이지, 알약 내부에 어떤 성분의 가루들이 있는지, 어떤 조합으로 만들어져 나의 병을 완화시키는 것인지는 알 수 없다.이러한 캡슐화을 활용, 내부 구현을 숨김에 따라 객체를 이용하는 사람은 기능 이용에만 집중할 수 있고 기능 구현자는 변경에 조금 더 유연하게 대처할 수 있다.다형성다형성이란 객체의 속성, 기능이 상황에 따라 다양한 형태를 가질 수 있는 성질을 의미한다.위의 코드를 다시 한번 살펴보자.interface 약 {    void 사용하기();} class 감기약 implements 약 {    @Override    public void 사용하기(){        // ...    }}class 바르는약 implements 약 {    @Override    public void 사용하기(){        // ..    }}class Main {    public static void main(String[] args){        약 감기약 = new 감기약();        감기약.사용하기();        약 바르는약 = new 바르는약();        바르는약.사용하기();    }}인터페이스에 정의된 메소드를 오버라이딩 하면서 각각의 클래스의 맥락에 맞게 행위를 정의했다. 먹는 약과 바르는 약은 ‘약’이라는 상처를 낫게하는 공통적인 특성이 있지만 사용하는 방법은 다르기 때문에,같은 이름의 메소드이지만 상황에 따라 다른 방식으로 역할을 수행할 수 있게 해야 한다.결국 다형성이란 ‘한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것’을 의미하며 상위 타입의 참조변수로 하위 객체를 참조할 수 있도록 하는 것이다.상속class 약 {        public void 사용하기(){        System.out.println(\"약을 먹었다!\");    }} class 알약 extends 약 {}class 시럽약 extends 약 {}class 바르는약 extends 약 {    @Override    public void 사용하기(){        System.out.println(\"약을 상처부위에 발랐다!\");    }}class Main {    public static void main(String[] args){        알약 감기약 = new 알약();        감기약.사용하기();        바르는약 후시딘 = new 바르는약();        후시딘.사용하기();    }    // 출력    // 약을 먹었다!    // 약을 상처부위에 발랐다!}상속이란 상위 클래스의 기능들을 이어받아 재활용하거나 새로 정의할 수 있게 하는 행위이다.비슷한 속성의 클래스들끼리 반복적으로 사용되는 기능, 속성들을 정의해두고 재사용하면서 코드의 반복을 줄일 수 있다.객체지향의 5가지 설계 원칙(SOLID)단일 책임 원칙 - SRP (Single Responsibility Principle)하나의 클래스는 하나의 기능만 수행해야 한다는, 한 가지 업무에만 책임을 가져야 한다는 원칙이다.물론 이 기능, 책임이란게 상황마다 사람 생각마다 달라질 수 있기 때문에 절대적인 기준은 존재하지 않지만하나의 클래스가 경계없이 여러 기능을 수행한다면 프로그램의 유지보수성이 현저히 낮아진다.개방 폐쇄 원칙 - OCP (Open Closed Principle)클래스는 기능 확장에 열려있어야 하고, 수정에는 닫혀있어야 한다는 원칙이다.새로운 기능을 추가해야 할 때 손쉽게 확장할 수 있어야 하지만 이에 따른 추가적인 수정이 최소화 되어야 한다는 뜻이다.코드로 예시를 살펴보자.class Car {\tString type;        Car(String type) {    \tthis.type = type;    }}class DriveCar {    void drive(Car car) {        if(car.type.equals(\"스포츠카\")) {            System.out.println(\"부우우우웅\");        } else if(car.type.equals(\"경운기\")) {            System.out.println(\"덜덜덜덜\");        }    }}public class Main {    public static void main(String[] args) {        DriveCar driveCar = new DriveCar();                Car sports = new Car(\"스포츠카\");        Car duldul = new Car(\"경운기\");        driveCar.drive(sports); // 부우우우웅        driveCar.drive(duldul); // 덜덜덜덜    }}위의 코드는 변경과 수정에 굉장히 취약한 구조를 가지고 있다.차의 종류가 추가될때마다 기존의 if 분기에 코드를 계속 추가, 수정 작업을 거쳐야 한다.만약 차의 종류가 100가지만 넘어가도 if절의 코드는 가독성이 현저히 안 좋아질 것이며 유지보수 또한몹시 어려워진다.interface Car {\tvoid drive();}class SportsCar implements Car{    void drive() {      System.out.println(\"부우우우웅\");    }}class FarmerCar implements Car{    void drive() {      System.out.println(\"덜덜덜덜\");    }}class DriveCar {    void drive(Car car) {        car.drive();    }}public class Main {    public static void main(String[] args) {        DriveCar driveCar = new DriveCar();                Car sports = new SportsCar();        Car duldul = new FarmerCar();        driveCar.drive(sports); // 부우우우웅        driveCar.drive(duldul); // 덜덜덜덜    }}위와 같이 구성하게 된다면 기능을 추가해야 할 때새로운 클래스에 대해서만 집중하면 되고 기존 코드의 수정에 대해 크게 걱정하지 않아도 된다.리스코프 치환 원칙 - LSP (Liskov Substitution Principle)자료형 S가 자료형 T의 서브타입라면 필요한 프로그램의 속성(정확성, 수행하는 업무 등)의 변경 없이 자료형 T의 객체를 자료형 S의 객체로 교체(치환)할 수 있어야 한다는 원칙이다.쉽게 풀어쓰자면 상위 클래스 타입으로 객체를 선언, 하위 클래스로 인스턴스 생성 후부모의 메서드를 사용해도 동작이 의도대로 흘러가야 한다는 것이다.void main() {    Collection data = new ArrayList();    data = new HashSet();         data.add(1); }위의 코드에서는 Collection 이라는 최상위 클래스 타입으로 변수 선언 후 구현체는 교체되었지만 모두 Collection의 서브 클래스들이기 때문에 의도한대로 동작하는 것을 확인할 수 있다.인터페이스 분리 원칙 - ISP (Interface Segregation Principle)인터페이스를 사용처에 맞게 적절한 단위로 분리해야한다는 원칙이다.단일 책임 원칙(SRP)의 주체가 클래스였다면 ISP는 그 주체가 인터페이스로 변경되었다고 생각하면 된다.인터페이스를 목적에 맞게 잘 설계, 분리하여 용도에 적합한 인터페이스를 제공하여차후에 수정사항 발생 시 인터페이스 자체가 변경되는 행위를 방지해야 한다.의존 역전 원칙 - DIP (Dependency Inversion Principle)클래스를 참조하는 상황에서 구현체를 직접 참조하지 말고 상위 요소(추상 클래스, 인터페이스)를 참조하라는 원칙이다.의존 관계 형성 시 구현 클래스는 변화가 잦을 수 있기 때문에, 비교적 변화가 발생하지 않는 상위의 인터페이스나 추상 클래스 등에 의존하는 것을 권장하는 원칙이다.참고  위키백과, SOLID (객체 지향 설계), https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84)  심플에디, 쉽게 설명하는 객체 지향 프로그래밍의 본질, https://www.youtube.com/watch?v=zgeCwYWzK-k  코드스테이츠, 객체 지향 프로그래밍의 4가지 특징ㅣ추상화, 상속, 다형성, 캡슐화, https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95  inpa, 객체 지향 설계의 5가지 원칙 - S.O.L.I.D, https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID"
  },
  
  {
    "title": "자바의 가비지 컬렉터 종류",
    "url": "/blog/posts/%EC%9E%90%EB%B0%94_%EA%B0%80%EB%B9%84%EC%A7%80%EC%BB%AC%EB%A0%89%ED%84%B0_%EC%A2%85%EB%A5%98/",
    "categories": "Language",
    "tags": "",
    "date": "2023-09-23 00:00:00 +0900",
    





    
    "snippet": "개론자바의 가비지 컬렉션 알고리즘은 기본적으로 Stop The World 이벤트를 전제하에 구성된다.Stop The World 이벤트 발생 시 모든 스레드가 일시 정지되고, 성능에 치명적이기 때문에이를 개선하기 위해 다양한 방식의 GC가 개발되고 있다.자바에는 어떤 GC가 존재하는지, 종류별 특징은 무엇인지 알아보자GC의 종류Serial GCGC를 처...",
    "content": "개론자바의 가비지 컬렉션 알고리즘은 기본적으로 Stop The World 이벤트를 전제하에 구성된다.Stop The World 이벤트 발생 시 모든 스레드가 일시 정지되고, 성능에 치명적이기 때문에이를 개선하기 위해 다양한 방식의 GC가 개발되고 있다.자바에는 어떤 GC가 존재하는지, 종류별 특징은 무엇인지 알아보자GC의 종류Serial GCGC를 처리하는 스레드가 한개이며 GC 수행 시 Stop the world, 모든 어플리케이션 스레드가 정지된다.우리가 기본적으로 배운 참조된 객체 식별 후 메모리를 정리하는 방식(mark-sweep-compact)이 사용된다.메모리 용량이 작고 CPU 코어 갯수가 적을 때 사용하기 적합하다.Parallel GC(=Throughput GC)Parallel GC는 Serial GC와 기본적인 작동 방식은 같지만 GC를 처리하는 쓰레드가 여러 개여서 Serial GC보다 더 나은 성능을 보여준다.메모리 용량이 어느 정도 충분하고 다중 코어 CPU를 사용할 때 적합하다.CMS(Concurrent Mark Sweep) GC (=Low Latency GC)stop the world 시간이 매우 짧게 발생하는 방식이다.기존 Serial GC에서는 모든 애플리케이션 스레드를 정지 후 GC를 시작하는데,이 과정은 다음과 같이 2단계로 세분화 할 수 있다.  참조 여부 확인  사용하지 않는 객체 청소CMS GC는 위와 같이 하나의 기능 안에서 이루어지던 2가지 작업을 세분화함과 동시에 별도의 스레드로 관련 작업을 수행한다.먼저 initial mark 단계에서 생존한 객체만 탐색한 후 stop the world를 종료한다.그리고 Concurrent Mark 단계에서 해당 객체들을 별도로 추적하여 참조가 되고 있는지 확인한다.이 작업은 애플리케이션 스레드와 동시에 진행된다.Remark 단계에서는 Concurrent Mark 단계에서 새로 할당된 객체나 참조가 끊긴 객체가 존재하는지 확인한다. 마지막으로 Concurrent Sweep 단계에서 GC 대상으로 선정된 객체들을 정리한다. 이 작업 또한 다른 스레드들과 동시에 진행된다.애플리케이션의 빠른 응답 속도가 중요할 때 사용된다.하지만 동시에 다수의 프로세스가 진행되기 때문에 다른 GC 방식보다 메모리와 CPU를 더 많이 사용하며,Compaction 단계가 기본적으로 수행되지 않아서 메모리 파편화가 많이 발생할 수 있다.만약 Compaction 작업을 수행한다면 다른 GC 방식들에 비해 오히려 stop the world 시간이 길어져 기존의 장점이 상쇄되기 때문에 사용에 신중을 기해야 한다.G1 GC  Humonogous: 용량이 큰 객체를 저장하기 위한 공간  Available/Unused: 아직 사용되지 않은 공간G1 GC는 기존의 GC들과는 전혀 다른 접근법을 가진다.young, old의 구역이 명확했던 이전 GC들과 달리 G1 GC는 전체 힙 메모리 영역을 특정한 역할로 나누며,배정되는 크기와 역할은 동적으로 변경된다.먼저 Old Region(=한개의 칸)에 존재하는 객체들이 참조하는 Survivor Region을 탐색 후, 해당 객체들을 스캔한다.GC에서 제외할 객체를 선별 후, 살아있는 객체가 가장 적은 Region을 청소한다.그 후 해당 블록에서 생존한 객체들은 새로운 Region(Available/Unused)으로 복사, 정렬하여 파편화를 방지한다.그동안 언급한 GC들에 비해 훨씬 빠른 퍼포먼스를 보인다고 하며, 이러한 바둑판식 발상은 다음에 나올 GC에서도 사용된다.Z GCStop The World 시간을 최대한 작게(10ms 이하)하는 것을 목표로 개발된 GC이다.힙의 모든 살아있는 객체를 식별하고 추적하는 Marking 단계,객체들을 재배치하는 Relocation 단계,재배치된 객체들의 참조를 새로 업데이트 하는 Remapping 단계,제거된 객체를 모두 회수하는 Reclaim까지 크게 4단계의 동작으로 구분된다.다음과 같은 64비트 포인터를 이용한다고 하며,finalizer을 통해서만 참조되는 Finalizable 부분,재배치 여부를 판단하는 Remapped,오브젝트의 생존 여부 판별에 사용되는 Marked 1 / 0이 존재한다고 한다.글들을 많이 읽어봤는데 ZGC는 단시간에 이해하기에는 역부족인 것 같다. 차후 다시 정리해야겠다.참고  jaehoney, JVM - GC 알고리즘 알아보기! (feat. JDK 버전 별 Default), https://jaehoney.tistory.com/301  naver d2, Java Garbage Collection, https://d2.naver.com/helloworld/1329  huisam, JVM과 Garbage Collection - G1GC vs ZGC, https://huisam.tistory.com/entry/jvmgc  naver d2, ZGC의 기본 개념 이해하기, https://d2.naver.com/helloworld/0128759?ref=codenary  choiseokwon, Java: Z Garbage Collection (ZGC), https://choiseokwon.tistory.com/373  드림어스컴퍼니 블로그, ZGC에 대해서, https://www.blog-dreamus.com/post/zgc%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C"
  },
  
  {
    "title": "자바의 가비지 컬렉터",
    "url": "/blog/posts/%EC%9E%90%EB%B0%94_%EA%B0%80%EB%B9%84%EC%A7%80%EC%BB%AC%EB%A0%89%ED%84%B0/",
    "categories": "Language",
    "tags": "",
    "date": "2023-09-22 00:00:00 +0900",
    





    
    "snippet": "개론대부분의 고수준 프로그래밍 언어들은 개발자가 메모리를 직접 해제하지 않는다.별도의 프로그램이 동적으로 할당된 메모리의 여유분을 관리하는데 이를 가비지 컬렉터라고 한다.그에 반해 c, c++과 같이 기계에 조금 더 가까운 언어들은 메모리 관리에 대한 책임이 전적으로 개발자에게 있다.그렇다면 가비지 컬렉터는 어떤 방식으로 작동하는지 자바의 사례를 통해...",
    "content": "개론대부분의 고수준 프로그래밍 언어들은 개발자가 메모리를 직접 해제하지 않는다.별도의 프로그램이 동적으로 할당된 메모리의 여유분을 관리하는데 이를 가비지 컬렉터라고 한다.그에 반해 c, c++과 같이 기계에 조금 더 가까운 언어들은 메모리 관리에 대한 책임이 전적으로 개발자에게 있다.그렇다면 가비지 컬렉터는 어떤 방식으로 작동하는지 자바의 사례를 통해 알아보자.가비지 컬렉션가비지 컬렉션이란가비지 컬렉션은 힙 메모리에서 사용 중인 개체와 사용되지 않는 개체를 식별하고, 사용되지 않는 개체를 삭제하는 프로세스이다.여기서 사용 중인 개체의 의미는 현재 어플리케이션이 해당 개체에 대한 포인터를 유지하고 있음을 의미, 즉 참조를 하고 있다는 뜻이다.pubilc void main(){    A a = new A(); // 객체 할당    a = null; // 참조관계 끊어짐}이를 자바 관점에서 서술하자면 스택에 변수가 할당되고, 힙에 객체가 할당 되었을 때 변수와 참조하고 있는 힙의 객체가 연결이 끊어진 상황을 의미한다.이러한 개체는 더 이상 프로그램에 필요하지 않기 때문에 메모리를 회수해야 할 대상이다.C와 같은 프로그래밍 언어에서 메모리 할당 및 할당 해제는 수동으로 이루어지지만, 자바에서는 메모리 할당 해제 프로세스가 자동으로 처리되며, 이러한 작업을 가비지 컬렉션이라 부른다.진행 과정1. 마킹먼저 사용 중인 메모리와 사용하지 않는 메모리를 식별한다.위의 그림에서 현재 참조 중인 객체는 파란색이고, 참조가 끊긴 개체는 주황색으로 표시되어 있다.이러한 마킹을 하기 위해 메모리의 모든 개체를 스캔해야 하며, 메모리 가용량에 따라 시간이 오래 걸릴 수 있다.2. 일반 삭제참조가 끊긴 개체를 삭제하고, 여유 공간을 확보한다. 그리고 어느 부분에 새 개채를 할당할 수 있는지 여유 공간에 대한 정보를 획득한다.2a. 압축을 통한 삭제성능 향상을 위해서는 참조가 끊긴 개체를 삭제할 뿐만 아니라 나머지 개체들을 연속되게 재배치 하는 것도 가능하다.이렇게 하면 메모리 파편화를 방지하여 새 메모리 할당 퍼포먼스가 좋아질 수 있다.세대(Generation)세대별 가비지 수집의 필요성위에서 기술한 방식으로 JVM의 모든 개체를 스캔, 압축하는 것은 비효율적일 수 있다.어플리케이션이 실행되면서 더 많은 개체가 할당될 것이고, 스캔해야 하는 목록이 늘어남에 따라 가비지 수집 시간은 비례하게 늘어난다.그러나 점차 개발을 하며 대부분의 개체는 금방 할당되었다가 해제되는, 즉 수명이 짧은 개체의 수가 훨씬 많다는 것이 경험적으로 분석되었다.Y축은 할당된 개체의 갯수이며 X축은 시간이 지남에 따라 남아있는 개체의 숫자이다.(근데 이 차트는 뭘 근거로 만들어 졌는지는 나도 모르겠다… 오라클 내부 데이터인가?)위의 차트와 같이 시간이 지나면서 살아남는 개체의 수는 급격하게 적어지고, 대부분은 얼마 지나지 않아 참조가 끊기는, 소멸되는 것을 볼 수 있다.세대별 특징JVM은 그래서 힙에 할당된 개체들을 다음과 같은 4개의 세대로 크게 구분한다.그런데 자바 버전이 업데이트 되면서 위와 같은 구분이 약간은 변동되었고, 지금은 다음과 같은 구조를 가지고 있다.미리 변경된 영역에 대해서만 설명을 하자면, 메타스페이스는 클래스와 메소드의 메타데이터들이 저장되는 영역이다. 클래스가 로딩될 때 메타스페이스에 클래스 정보가 저장되는데 대규모의 프로그램에서는 당연히 클래스 정보도 많을 것이고, 메타스페이스의 사용량 또한 늘어나게 된다.기존의 Perm 영역은 자바 힙 영역에 포함되었기 때문에 메모리 확보에 비교적 제약이 있었으나, 이제는 OS 레벨에서 관리되는 Native 메모리 영역으로 옮겨졌기 때문에 비교적 여유로운 상한선 확보가 가능해졌다.다시 본론으로 돌아와서 각 세대별에 대한 설명을 마저 하자면, Young Generation은 모든 개체가 할당되는 시작점이다. Young Generation이 가득 차게 되면 마이너 가비지 컬렉션이 발생하게 된다. 가장 가비지 수집이 활발한 영역이며, 이곳에서 생존하면 Old Generation으로 이동하게 된다.Old Generation으로 넘어온 개체도 점점 쌓이게 되면 가비지 컬렉션이 발생하는데, 여기서 일어나는 가비지 컬렉션을 메이저 가비지 컬렉션이라고 한다.마이너, 메이저 가비지 컬렉션 둘다 실행되고 완료되기 전까지 Stop The World 이벤트, 즉 모든 애플리케이션의 스레드가 정지하게 된다. 이러한 방식의 GC를 극복하기 위해 다양한 방식의 가비지 컬렉션이 개발되었는데(Parallel GC, CMS GC, G1 GC, Z GC) 여기 쓰기엔 글이 너무 길어지니 다른 게시글로 정리하도록 하겠다.세대별 가비지 컬렉션1. eden 할당제일 먼저 eden 영역에 새로운 객체들이 할당된다.2. 마이너 GC그리고 eden 공간이 가득 차게 된다면 마이너 GC가 발생한다.3. S0 이동여기서 현재도 참조 중, 사용 중인 객체는 s0 으로 이동된다. 참조하고 있지 않는 객체는 마이너 GC와 함께 삭제된다.4. S1 이동위의 세 과정을 반복한 후, S0에서 또 다시 생존한 객체는 S1으로 이동하게 된다.5. Old Gen 이동마이너 GC가 반복되며 생존한 객체들은 더 상위 단계인 Old Gen으로 이동하며, 이 영역이 가득차게 되면 메이저 GC가 발생한다.참고      Oracle, Java Garbage Collection Basics, https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html        bebeside77, Java Metaspace에 대해서, https://sheerheart.tistory.com/entry/Java-Metaspace%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C        BE Developer, Java 8에서 JVM의 변화 : PermGen이 사라지고 Metaspace가 등장하다., https://goodgid.github.io/Java-8-JVM-Metaspace/  "
  },
  
  {
    "title": "컴퓨터의 숫자 연산",
    "url": "/blog/posts/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98_%EC%88%AB%EC%9E%90%EC%97%B0%EC%82%B0/",
    "categories": "OS",
    "tags": "",
    "date": "2023-09-07 00:00:00 +0900",
    





    
    "snippet": "컴퓨터의 진법우리는 컴퓨터가 2진수로 숫자를 처리한다고 많이 접했다.어찌보면 당연한 선택이기도 하다. 메모리 셀, 플립플롭 등에 데이터를 저장하는 컴퓨터는전하가 일정치를 넘어서 존재하느냐(1), 존재하지 않느냐(0) 외에 추가적인 선택지를 고안하기는쉽지 않기 때문이다.3진법으로 컴퓨터를 구성하는 개념과 시도 또한 있는 것으로 알고 있다.몇 년 전에 한...",
    "content": "컴퓨터의 진법우리는 컴퓨터가 2진수로 숫자를 처리한다고 많이 접했다.어찌보면 당연한 선택이기도 하다. 메모리 셀, 플립플롭 등에 데이터를 저장하는 컴퓨터는전하가 일정치를 넘어서 존재하느냐(1), 존재하지 않느냐(0) 외에 추가적인 선택지를 고안하기는쉽지 않기 때문이다.3진법으로 컴퓨터를 구성하는 개념과 시도 또한 있는 것으로 알고 있다.몇 년 전에 한국 연구진이 발표한, 누설전류를 이용해 추가적인 상태를 나타내는 3진법 반도체 또한 그 일환이다.하지만 여전히 우리가 사용하는 대다수의 컴퓨터는 2진법으로 구성되어 있다.2진법은 만능일까?우리는 10진법을 사용하며 살고 있다. 하지만 컴퓨터의 세계는 2진법이다.여기서 숫자 표기의 괴리가 나타나게 된다.위와 같은 원판이 존재한다고 생각해보자.10진법은 저 원판을 10개로 나누어 생각하는 개념이고, 2진법은 2개로 나누어 생각하는 개념이다.만약 저 원판 중 10진법으로 표기된, 10개로 나뉘어진 원판 중 하나를 2진법으로 표기하고 싶어졌다.어떻게 해야할까? 정확한 표기가 가능할까?한번 계속 나누어 보자.2진법의 원판을 10진법의 조각 한 개와 같게 하기 위해 지속적으로 나누어 봤으나, 이미 몇 단계만 진행해도 같게 만들 수 없다는 사실을 깨닫게 된다.저 과정을 범위를 좁혀가며 숫자로 정리해보자면 다음과 같다.1. 1 / 2 = 0.5 =&gt; 0 ---- 0.1 ---- 0.52. 0.5 / 2 = 0.25=&gt; 0 ---- 0.1 ---- 0.253. 0.25 / 2 = 0.125=&gt; 0 ---- 0.1 ---- 0.1254. 0.125 / 2 = 0.0625=&gt; 0.0625 ---- 0.1 ---- 0.1255. 0.0625 + (0.0625 / 2)=&gt; 0.09375 ---- 0.01 ---- 0.0125이처럼 우리가 쓰는 10진법과 컴퓨터의 2진법은 특정 상황에서 오차가 날 수 밖에 없는 구조이다.그렇다면 컴퓨터 or 개발자는 어떤 방식으로 이러한 오차를 줄이거나 방지하고 있을까?다양한 방법들부동 소수점이 방법은 오차를 방지한다기보다는, 효율적인 저장 기법이 더 어울리는 것 같다.부동 소수점은 영어로 floating point(점이 둥둥 떠다닌다) 즉, 소수점의 위치가 가변적이다.부동이 있다면 고정도 있을터, 하지만 이 방식은 각각에 할당된 크기가 고정되어 있기 때문에아주 크거나 or 작은 수를 표현하기에는 제한적이었다.그에 반해 부동 소수점 표기방식은 지수부와 가수부를 이용해 조금 더 유연한 표기가 가능하다.숫자 260.5를 부동 소수점 방식으로 표기하는 예를 들어보자.260.5(10) == 100000100.1(2)=&gt; 1의 바로 뒤까지 소수점을 이동시킨다1.000001001(2) * 2^8 == 100000100.1(2)부호 (+), 지수 8부호비트 : 0 (양수)지수비트 : 10000111 (127 + 8 = 135) // IEEE 754 표현 방식에 따라 127을 더해줌가수비트 : 000001001다음과 같이 컴퓨터는 수를 계산한다.정수 변환 계산위와 같은 부동 소수점을 이용해도 결국 한치의 오차도 없이 계산을 하는 것은 힘들다.그렇다면 이런 숫자 계산이 중요한 금융권이나, 코인 거래소 같은 곳들은 어떤 방식으로 문제를 해결할까?문제가 발생하는 방식을 사용하지 않으며 해결을 했다. 무슨 말이냐면, 소수점이 발생한다면 곱연산을 해서 정수로 변환 후 처리하거나 동등한 값으로 치환을 하는 것이다.요즘 핫한 코인의 예를 보자.비트코인  분할 가능 범위 : 소수점 아래 8자리  0.00000001 BTC = 1 Satoshi  1 BTC = 100000000 Satoshi이더리움  분할 가능 범위 : 소수점 아래 18자리  0.000000000000000001 Ether = 1 Wei  1 Ether = 100000000000000000 Wei다음과 같은 방식으로 소수점으로 일어날 수 있는 문제 상황을 미연에 방지했다.참고  전자신문 etnews, [KISTI과학향기]3진법 반도체를 구현하다, https://www.etnews.com/20190809000469  개발자 라라, 컴퓨터에서는 0.1 x 0.1 이 0.01이 아닙니다, https://www.youtube.com/watch?v=vOO-oLS0H68  평범한 게임 개발자, 컴퓨터의 실수 표현 방법, https://gamedevlog.tistory.com/24  steemit, 부동 소수점(Floating Point)란 무엇인가?, https://steemit.com/kr/@modolee/floating-point"
  },
  
  {
    "title": "처리장치, 처리장치의 구성요소",
    "url": "/blog/posts/%EC%B2%98%EB%A6%AC_%EC%9E%A5%EC%B9%98/",
    "categories": "Hardware",
    "tags": "",
    "date": "2023-08-31 00:00:00 +0900",
    





    
    "snippet": "처리장치중앙처리장치(CPU: Central Processing Unit)각종 데이터 처리, 연산을 수행하는 처리장치와 연산을 제어하는 제어장치가 결합된 형태이다.처리장치는 데이터를 처리하는 연산을 실행하며, 제어장치는 연산의 실행순서를 결정한다.구성산술논리연산장치(ALU)산술, 논리, 비트 연산등의 연산을 수행한다ALU는 독립적으로 데이터를 처리하지 ...",
    "content": "처리장치중앙처리장치(CPU: Central Processing Unit)각종 데이터 처리, 연산을 수행하는 처리장치와 연산을 제어하는 제어장치가 결합된 형태이다.처리장치는 데이터를 처리하는 연산을 실행하며, 제어장치는 연산의 실행순서를 결정한다.구성산술논리연산장치(ALU)산술, 논리, 비트 연산등의 연산을 수행한다ALU는 독립적으로 데이터를 처리하지 못하며, 반드시 레지스터들과 조합하여 데이터를 처리한다.레지스터(Register)연산에 사용되는 데이터나 연산의 결과를 저장한다마이크로 연산레지스터에 저장되어 있는 데이터에 대해 이루어지는 기본적인 연산이다.한 레지스터의 내용을 다른 레지스터로 옮기거나, 두 레지스터의 내용을 합하고, 레지스터의 내용을 1만큼 증가시키는 것 등 처리장치의 동작원리를 이해하기 위해서는 마이크로 연산에 대한 이해가 수반되어야 한다.레지스터 전송 마이크로 연산, 산술 마이크로 연산, 논리 마이크로 연산, 시프트 마이크로 연산 등이 존재한다.레지스터 전송 마이크로 연산한 레지스터에서 다른 레지스터로 2진 데이터를 전송하는 연산이다.레지스터 사이의 데이터 전송은 연산자 ‘&lt;-‘ 로 표시한다.R2 &lt;- R1다음과 같은 표시는 레지스터 R1의 내용이 레지스터 R2로 전송된다는 뜻이며, 여기서 R1은 출발 레지스터, R2는 도착 레지스터라 부른다.산술 마이크로 연산레지스터 내의 데이터에 대해서 실행되는 산술 연산이다.기본적인 산술연산으로는 덧셈, 뺄셈, 1 증가, 1 감소, 보수 연산이 존재한다.            기호 표시      의미              R0 &lt;- R1 + R2      R1과 R2의 합을 R0에 저장              R1 &lt;- R1 + 1      R1에 1을 더함 (상승 카운트)              R1 &lt;- R1 - 1      R1에 1을 뺌 (하강 카운트)      논리 마이크로 연산레지스터 내의 데이터에 대한 비트를 조작하는 연산이며, 기본적인 논리연산으로는 AND, OR, XOR, NOT 연산이 존재한다.            기호 표시      의미              R0 &lt;- R1 ∧ R2      AND              R0 &lt;- R1 ∨ R2      OR              R0 &lt;- R1 ⊕ R2      XOR      시프트 마이크로 연산레지스터 내의 데이터를 시프트 시키는 연산이며, 데이터의 측면이동에 사용된다.시프트 연산을 수행하더라도 출발 레지스터의 값은 변하지 않으며 출력비트의 값은 버려진다.            유형      기호 표시      출발지 R2      목적지 R1              왼쪽 시프트      R1 &lt;- sl R2      1 0 0 1 1 1 1 0      0 0 1 1 1 1 0 0              오른쪽 시프트      R1 &lt;- sr R2      1 1 1 0 0 1 0 1      0 1 1 1 0 0 1 0      참고  방송통신대학교, 컴퓨터 구조 4강(김형근), 처리장치(I)"
  },
  
  {
    "title": "컴퓨터 명령어, 명령어 형식, 종류",
    "url": "/blog/posts/%EC%BB%B4%ED%93%A8%ED%84%B0_%EB%AA%85%EB%A0%B9%EC%96%B4/",
    "categories": "Hardware",
    "tags": "",
    "date": "2023-08-29 00:00:00 +0900",
    





    
    "snippet": "컴퓨터 명령어OPERAND와 OP-CODE컴퓨터 명령어의 기본적인 구성요소는 오퍼레이션 코드(Op-code)와 오퍼랜드(Operand)로 구분된다.Op-Code는 CPU에서 실행될 연산을 지정하는 부분이며,오퍼랜드는 연산을 실행하는 데 필요한 데이터 혹은 주소 값을 가지고 있다.명령어의 분류컴퓨터 명령어 형식은 크게 2가지로 다음과 같이 분류된다.  ...",
    "content": "컴퓨터 명령어OPERAND와 OP-CODE컴퓨터 명령어의 기본적인 구성요소는 오퍼레이션 코드(Op-code)와 오퍼랜드(Operand)로 구분된다.Op-Code는 CPU에서 실행될 연산을 지정하는 부분이며,오퍼랜드는 연산을 실행하는 데 필요한 데이터 혹은 주소 값을 가지고 있다.명령어의 분류컴퓨터 명령어 형식은 크게 2가지로 다음과 같이 분류된다.  오퍼랜드의 기억장소에 따른 명령어 형식  오퍼랜드의 수에 따른 명령어 형식기억 장소에 따른 명령어 형식누산기를 이용하는 명령어 형식누산기(Accumulator)를 가진 컴퓨터 구조에서 사용되는 형식이다.누산기란 누산기를 가진 컴퓨터 구조에서 중앙처리장치에 있는 유일한 데이터 레지스터로서명령어가 수행될 때 오퍼랜드를 기억시키는 레지스터이다.누산기를 이용한 명령어는 다음과 같이 동작한다.1. ADD X ; AC &lt;- AC + M[X]2. LOAD X ; AC &lt;- M[X]3. STORE X ; M[X] &lt;- AC1번과 같이 덧셈을 하라는 명령어가 있다.한 가지 특이한 점이 있다면 덧셈의 대상이 한 가지밖에 없다는 것인데,보통 이런 식의 표기는 CPU 안의 특정 장소에 데이터가 존재한다는 전제를 암묵적으로깔고 가는 것이고, 그 데이터가 있는 특정 장소가 바로 누산기이다.그러므로 이 명령어의 뜻은 ‘누산기에 있는 내용과 기억장치 X번지에 있는 내용을 더해서 누산기로 전송하라’ 라는 뜻이다.2번 또한 누산기를 이용한다는 전제하에 ‘기억장치 X번지에 있는 내용을 누산기로 적재해라’라는 뜻과 같고,3번도 ‘누산기의 내용을 기억장치 X번지에 저장하라’ 라고 해석할 수 있다.다중 레지스터를 이용하는 명령어 형식다중 레지스터를 가진 컴퓨터 구조는 중앙처리장치 내에 여러 개의 레지스터를 가지고 있는 컴퓨터이다.1. ADD R1, R2, R3 ; R3 &lt;- R1 + R22. ADD R1, R2 ; R2 &lt;- R1 + R23. MOVE R1, R2 ; R2 &lt;- R14. LOAD X, R1 ; R1 &lt;- M[X]5. STORE R1, X ; M[X] &lt;- R11번 명령어는 ‘레지스터 R1의 내용과 레지스터 R2의 내용을 더해서 레지스터 R3로 전송하라’ 와 같은 의미이며, 여기서 R1, R2 레지스터는 데이터가 출발한 곳이기 때문에 출발 레지스터라고도 부르며, 최종 결과가 옮겨진 R3 레지스터는 도착 레지스터 라고 표현하기도 한다.2번 명령어는 ‘레지스터 R1의 내용과 레지스터 R2의 내용을 더해서 레지스터 R2로 전송하라’라는 의미이다.3번은 ‘레지스터 R1의 내용을 레지스터 R2로 전송하라’, 4번은 ‘기억장치 X번지의 내용을 레지스터 R1에 적재하라’, 5번은 ‘레지스터 R1의 내용을 기억장치 X번지에 저장하라’와 같은 뜻이 된다.스택 구조를 이용하는 명령어 형식스택 구조 컴퓨터는 연산에 필요한 오퍼랜드들을 기억장치 스택에 기억시켜야 하고, 연산의 결과도 스택에 기억시키는 구조이다.후입선출인 스택의 구조 특성상 연산과 관련된 데이터들이 차곡차곡 쌓이게 되고,스택의 맨 위(Top Of Stack)를 기억하는 스택 포인터(SP)가 필요하다. 스택 포인터 또한 일종의 레지스터이며 자료를 꺼낼 때 마다 주소값을 아래칸으로 이동시켜야 한다.어차피 스택의 위쪽에서 지속적으로 데이터를 꺼내오기 때문에 오퍼랜드를 별도로 표시하지 않으며, OP-Code만 기입해준다.1. ADD ; TOS &lt;- TOS + TOS-12. PUSH X ; TOS &lt;- M[X]3. POP X ; M[X] &lt;- TOS이러한 스택 자료구조의 특성 때문에 1번 명령어는 ‘기억장치 스택의 맨 위의 내용과 그 아래의 내용을 더해서 스택의 맨 위로 전송하라’와 같은 뜻이된다.2번 명령어는 ‘기억장치 주소 X의 내용을 기억장치 스택의 맨 위로 전송하라’와 같은 뜻이 되며,3번은 ‘스택 데이터를 기억장치 X로 옮겨라’ 라는 뜻이다.오퍼랜드 수에 따른 명령어 형식오퍼랜드의 갯수에 따라 명령어를 분류하는 방식이며, 오퍼랜드의 갯수가 3개면 3주소 명령어, 2개면 2주소 명령어, 1개면 1주소 명령어, 0개면 0주소 명령어라고 부른다.3주소 명령어명령어 오퍼랜드의 개수가 세 개인 명령어 형식이다.만약 산술식 X = (A + B) * C 를 3주소 명령어를 이용해 프로그래밍 하면 다음과 같이 기술할 수 있다.X = (A + B) * C ADD A, B, R1 ; R1 &lt;- M(A) + M(B)MUL R1, C, X ; M(X) &lt;- R1 * M(C)3주소 명령어는 산술식을 프로그램화 하는데 있어서 프로그램의 길이가 짧아진다는 장점이 있으나, 2진 코드화 했을 때 세 개의 오퍼랜드를 나타내기 위한 비트 수가 다른 주소 명령어 형식보다 많이 필요하다는 단점이 있다.2주소 명령어똑같은 산술식을 2주소 명령어로 나타낸다면 다음과 같다.X = (A + B) * C LOAD A, R1 ; R1 &lt;- M(A)ADD B, R1 ; R1 &lt;- R1 + M(B)MUL C, R1 ; R1 &lt;- R1 * M(C)STORE R1, X ; M(X) &lt;- R13주소 명령어에 비해 명령어의 길이는 짧아졌으나 같은 내용을 수행하기 위해 계산해야 하는 명령어의 수는 증가된 것을 확인할 수 있다.1주소 명령어오퍼랜드의 개수가 하나인 명령어 형식으로, 기억장치로부터 오퍼랜드를 가져오거나 연산결과를 저장하기 위한 임시적인 장소로 누산기 레지스터를 사용한다.모든 연산은 누산기 레지스터와 기억장치에 저장된 오퍼랜드를 대상으로 수행하며, 프로그램을 수행하기 위해 사용되는 명령어의 수는 더욱 더 증가된다.0주소 명령어명령어의 길이가 매우 짧아져 기억공간을 적게 차지하지만, 특수한 경우를 제외하고는 많은 양의 정보가 스택과 기억장치 사이를 이동하게 되어 비효율적이다.주소 지정 방식프로그램 수행 시 오퍼랜드를 지정하는 방식으로, 명령어의 주소 필드를 변경하거나 해석하는 규칙을 지정한다. 주소지정방식을 사용하면 명령어의 수를 줄일 수 있는 효과적인 프로그래밍이 가능하다.유효 주소라는 개념을 사용하는데, 이는 주소지정방식의 각 규칙에 의해 정해지는 오퍼랜드의 실제 주소를 의미한다.            연산코드      주소지정방식      주소 혹은 오퍼랜드      다음과 같이 구성되며, 연산코드 필드는 수행할 연산의 종류를 지정하고주소지정방식 필드는 연산에 필요한 오퍼랜드의 주소를 알아내는 데 사용한다.주소 혹은 오퍼랜드 필드는 기억장치주소 혹은 레지스터를 나타낸다.주소 지정 방식의 종류로는  의미 주소 지정 방식  즉치 주소 지정 방식  직접 주소 지정 방식  간접 주소 지정 방식  레지스터 주소 지정 방식  레지스터 간접 주소 지정 방식  상대 주소 지정 방식  인덱스된 주소 지정 방식이 존재한다.참고  방송통신대학교, 컴퓨터 구조 3강(김형근), 컴퓨터명령어(II)"
  },
  
  {
    "title": "클라우드 컴퓨팅, 온프레미스와 클라우드",
    "url": "/blog/posts/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C_%EC%BB%B4%ED%93%A8%ED%8C%85/",
    "categories": "Devops",
    "tags": "",
    "date": "2023-08-20 00:00:00 +0900",
    





    
    "snippet": "클라우드 컴퓨팅온프레미스정보 서비스 제공에 요구되는 데이터 센터를 자체적으로 보유하고 운용하는 방식이다.클라우드 컴퓨팅 기술이 나오기 전까지 사용되던 일반적인 인프라 구축 방식이며,개인 혹은 기업이 서비스를 제공하기 위해 구축한 서버를 말한다.시스템 구축 단계  요구 기능 수집          IT 리소스 요구량 추정 및 추가 리소스 확보 계획을 수립...",
    "content": "클라우드 컴퓨팅온프레미스정보 서비스 제공에 요구되는 데이터 센터를 자체적으로 보유하고 운용하는 방식이다.클라우드 컴퓨팅 기술이 나오기 전까지 사용되던 일반적인 인프라 구축 방식이며,개인 혹은 기업이 서비스를 제공하기 위해 구축한 서버를 말한다.시스템 구축 단계  요구 기능 수집          IT 리소스 요구량 추정 및 추가 리소스 확보 계획을 수립한다        설계          구체적 하드웨어 및 소프트웨어 선정, 아키텍쳐를 작성한다        조달          IT 리소스별 벤더사 선정 및 의뢰, 협상을 진행한다        구축          하드웨어 배치, 연결 및 테스트, 소프트웨어를 선정한다      기업내의 기술력과 경험을 갖춘 인적 자원을 활용한다        운영          H/W, S/W 자산의 관리 및 모니터링, 데이터 백업, 시스템 보안 대비를 진행한다      시설관리, H/W 임대, 유지보수, 네트워크 관리, 운영 담당자 인건비 등 다양한 요소의 부대비용이 발생하게 된다      온프레미스 시스템 구축 및 운영 비용  직접 비용          IT 장비 또는 장비 도입을 하기 위한 외주 비용이 발생한다        간접 비용          IT 장비를 사용하기 위해 사용되는 유지비용 및 기회비용이 발생한다.      클라우드 시스템온프레미스와 달리 클라우드 시스템은 사용자의 직접적인 관리 없이 리소스를 필요할 때 마다 제공받는 것을 말한다.종류로는 H/W 리소스를 제공하는 IaaS(Infrastructure as a service),H/W 리소스와 OS, S/W 개발을 위한 다양한 도구를 제공하는 PaaS(Platform as a service), H/W 리소스와 OS, S/W 모두를 제공하는 SaaS(Software as a service) 가 존재한다.배포 모델퍼블릭 클라우드다수의 사용자가 클라우드 제공자가 공급하는 서버 및 저장소와 같은IT 리소스를 공유하여 사용하는 모델이다.프라이빗 클라우드단일 조직이 독점적으로 데이터 센터를 구축하고 독점적으로 사용하는 모델이다.하이브리드 클라우드2개 이상의 CSP의 퍼블릭 클라우드의 인프라와 조직 내 구성된 프라이빗 클라우드 인프라가 결합된 모델이다.평상시에는 프라이빗 클라우드 형태로 서비스를 유지하다가 서비스 자원 요구량이 늘어날 시 퍼블릭 클라우드의 리소스를 활용한다.멀티 클라우드 또한 비슷한 개념인데, 애플리케이션 및 서비스를 분산시키기 위해 2개 이상의 퍼블릭 클라우드, 2개 이상의 프라이빗 클라우드, 퍼블릭과 프라이빗 클라우드의 조합 등 여러 클라우드의 조합을 활용하는 클라우드 컴퓨팅 모델이 존재한다.이는 다양한 조직의 클라우드 서비스로 자원을 분산함으로서 혹시 모를 리소스 제공자의 장애 대비에 효율적으로 대응할 수 있게 한다.참고  방송통신대학교, 클라우드 컴퓨팅 2강(정재화), 온프레미스와 클라우드"
  },
  
  {
    "title": "디지털 논리회로, 논리회로와 컴퓨터 명령어",
    "url": "/blog/posts/%EB%94%94%EC%A7%80%ED%84%B8_%EB%85%BC%EB%A6%AC%ED%9A%8C%EB%A1%9C/",
    "categories": "Hardware",
    "tags": "",
    "date": "2023-08-18 00:00:00 +0900",
    





    
    "snippet": "디지털 논리회로디지털 논리회로는 크게 2가지로 나뉜다.조합논리회로, 순서놀리회로로 구분되는데 구별의 기준은 기억소자의 유무이다.조합논리회로현재의 입력에 의해서만 출력이 결정되는 논리회로이다.종류로는 덧셈회로인 가산기, 뺄셈회로인 감산기 등이 존재한다.반가산기2진수의 덧셈을 수행하는 회로이며, 두 비트의 덧셈을 수행한다.덧셈의 결과 중 합을 뜻하는 S와...",
    "content": "디지털 논리회로디지털 논리회로는 크게 2가지로 나뉜다.조합논리회로, 순서놀리회로로 구분되는데 구별의 기준은 기억소자의 유무이다.조합논리회로현재의 입력에 의해서만 출력이 결정되는 논리회로이다.종류로는 덧셈회로인 가산기, 뺄셈회로인 감산기 등이 존재한다.반가산기2진수의 덧셈을 수행하는 회로이며, 두 비트의 덧셈을 수행한다.덧셈의 결과 중 합을 뜻하는 S와 올림수를 뜻하는 C(캐리)가 존재한다.전가산기2진수의 덧셈을 수행하는 회로이며, 세 비트의 덧셈을 수행한다.반감산기2진수의 뺄셈을 수행하는 회로이며, 두 비트의 뺄셈을 수행한다.한 가지 눈여겨 볼 점은 반가산기의 회로와 매우 유사한데, 반가산기에 NOT 게이트를 하나 추가하면같은 모양의 회로가 되는 것을 볼 수 있다.전감산기전감산기 또한 전가산기의 회로와 매우 유사한데, 전가산기의 회로에 NOT 게이트를 몇 개 추가한 모양인 것을 확인할 수 있다.가,감산기이러한 회로 유사도에 따라서 나온 것이 가,감산기이다.덧셈과 뺄셈 연산을 가산기만으로 수행하는 형태로, 감산기는 가산기에 인버터(NOT 게이트)를 추가한 형태이므로 가산기만 사용하여 감산을 수행하면 회로를 최소화 할 수 있다.MSI를 이용한 조합논리회로디지털 시스템에서 효과적인 조합논리회로를 설계하기 위해서는 주어진 기능을 수행하는데 필요한 게이트의 수를 최소화해야 한다.이를 위해 집적회로(IC)를 사용하며, 패키지화된 IC의 내부 게이트를 이용하면 경제적인 설계가 가능하다.대표적인 예시로는 인코더, 디코더, 멀티플렉서, 디멀티플렉서 등이 존재한다.인코더 / 디코더인코더는 부호화되지 않은 입력을 받아서 부호화된 출력을 내보내는 부호화기이다.2^n개의 입력와 n개의 출력을 가지고 있으며, 출력은 입력값에 대응하는 2진 코드를 생성한다.문자, 숫자, 기호등을 2진 코드로 변환시켜주는 조합논리회로 등에 사용된다.디코더는 인코더와 상대되는 개념으로, 부호화된 입력을 받아서 부호화되지 않은 출력을 내보내는 복호화기이다.n비트의 2진 코드를 최대 2^n 개의 서로 다른 정보로 바꾸어 준다. 기억장치에서 특정 번지를 선택할 때나 컴퓨터 명령어를 해독하는 데 사용된다.멀티플렉서 / 디멀티플렉서멀티플렉서는 여러 개의 입력선 중에서 하나를 선택하여 단일의 출력을 내보내는 조합논리회로이다.특정 입력선을 선택하기 위해서 선택변수를 사용하며 2^n개의 입력선 중에서 특정 입력선을 선택하기 위해서는 n개의 선택변수가 있어야 하며, 이러한 n개의 선택변수 조합에 의해 특정 입력선이 선택된다.데이터 선택기(data selector)라고도 하며, 약어로 MUX로 표현한다.컴퓨터 시스템에서 공통 버스 시스템을 구성하거나 여러 개의 레지스터 중 하나를 선택하는데 사용된다.디멀티플렉서는 멀티플렉서와 반대되는 동작을 수행하는 조합논리회로이며, 데이터 분배기 라고도 불린다.순서논리회로조합논리회로에 저장요소(플립플롭)를 추가한 회로이며, 저장요소의 상태와 입력번수에 의해서 출력이 결정된다.종류로는 곱셈회로인 승산기, 나눗셈회로인 제산기 등이 존재한다.플립플롭한 비트의 2진 정보를 저장할 수 있는 장치이며, 입력신호에 의해 상태를 바꾸도록 지시가 있을 때 까지 현재의 2진 상태를 유지하는 논리 소자이다.클럭 신호에 의해 출력 상태를 바꾸며, RS 플립플롭, D 플립플롭, JK 플립플롭, T 플립플롭 등이 존재한다.이러한 플립플롭으로 구성된 것이 레지스터이며 4개의 플립플롭이 존재하면 4비트 레지스터,8개가 존재하면 8비트 레지스터 등으로 불린다.레지스터데이터를 일시 저장하거나 전송하는 장치이다.여러 개의 플립플롭을 연걸하여 구성되며, n비트 레지스터는 n개의 플립플롭으로 구성되며이는 곧 n비트의 2진 정보를 저장할 수 있다는 말이기도 하다.데이터 적재 레지스터, 시프트 레지스터 등이 존재하며이러한 레지스터들은 여러 비트를 일시적으로 저장하거나, 배열된 비트를 좌, 우 자리이동을 시키는데 사용된다.카운터플립플롭을 사용해 만든 순서논리회로이며, 입력되는 클럭 펄스의 적용에 따라 미리 정해진 순서를밟아 가는 특수한 형태의 레지스터이다.외부의 입력이나 출력이 없으며 상태변화는 클럭펄스에 의해 수행된다.참고  방송통신대학교, 컴퓨터 구조 2강(김형근), 디지털논리회로(II) 및 컴퓨터 명령어(I)"
  },
  
  {
    "title": "스프링 컨테이너, 빈의 생성 과정",
    "url": "/blog/posts/%EC%8A%A4%ED%94%84%EB%A7%81_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/",
    "categories": "Backend",
    "tags": "",
    "date": "2023-07-22 00:00:00 +0900",
    





    
    "snippet": "스프링 부트의 자바 빈은 어떻게 생성될까?스프링 컨테이너에 등록되는 빈은 어떤 방식으로 생성되는지 궁금해졌다.그래서 한 번 인텔리제이로 코드를 따라가봤다. 아마 틀렸을 수도 있다…싱글톤이란?일단 스프링은 기본적으로 싱글톤으로 빈을 생성한다.그렇다면 싱글톤 패턴이 무엇인지 잠시 알아보자.  생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고...",
    "content": "스프링 부트의 자바 빈은 어떻게 생성될까?스프링 컨테이너에 등록되는 빈은 어떤 방식으로 생성되는지 궁금해졌다.그래서 한 번 인텔리제이로 코드를 따라가봤다. 아마 틀렸을 수도 있다…싱글톤이란?일단 스프링은 기본적으로 싱글톤으로 빈을 생성한다.그렇다면 싱글톤 패턴이 무엇인지 잠시 알아보자.  생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 이와 같은 디자인 유형을 싱글턴 패턴이라고 한다. 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용된다.라고 위키백과에 정의되어 있다.핵심은 하나의 객체만 생성되어야 한다는 것이고, 이를 통해 효율적인 자원 사용을 하겠다는 것이 목표다.구현 방법public class Singleton {    private static Singleton instance;    private Singleton(){    }    public static Singleton getInstance(){        if(instance == null){            instance = new Singleton();        }        return instance;    }} 가장 단순한 구현법이다.하지만 여러 스레드가 동시에 접근했을 때 하나의 인스턴스가 생성된다는 명제를 보장할 수 없다는 문제점이 있다.getInstance() 메소드에 synchronized 와 같은 키워드를 걸어서 해당 상황을 방지할 수는 있으나, 이는 성능 저하라는또다른 문제가 생기게 된다.public class Singleton {    private final static Singleton instance = new Singleton();    private Singleton(){    }    public static Singleton getInstance(){        return instance;    }} 이를 개선하기 위해 static 멤버의 특성을 이용, JVM이 최초 로딩 때 클래스를 로딩함과 동시에 인스턴스를 만들어 버리는 방법도 존재한다.하지만 이는 효율적인 자원 활용과는 거리가 존재한다. 해당 인스턴스를 사용 안 할 경우에도 생성되기 때문이다.public class Singleton {    private static class singleInstanceHolder {        private static final Singleton INSTACE = new Singleton();    }    public static Singleton getInstance(){        return singleInstanceHolder.INSTANCE;    }} public enum SingletonEnum {    INSTANCE;    public void helloWorld(){    }}가장 유명하면서 많이 사용되는 두 가지 방법이다.별도의 홀더 클래스를 만들어 인스턴스를 호출할 때 static 변수에 객체를 할당하거나, enum 클래스로 만드는 방법이다.빈은 어떻게 생성되는가?@SpringBootApplicationpublic class HelloApplication {    public static void main(String[] args) {        SpringApplication.run(Hello.class, args) // -&gt; 해당 함수 추적;    }}이제 스프링이 어떻게 컨테이너에 빈을 등록시키는지 본격적으로 알아보자.필자는 메인 클래스의 SpringApplication.run() 메소드를 중점적으로 추적해가며 코드를 가져왔다.public class SpringApplication {    // .....    public ConfigurableApplicationContext run(String... args) {\t\tlong startTime = System.nanoTime();\t\tDefaultBootstrapContext bootstrapContext = createBootstrapContext();\t\tConfigurableApplicationContext context = null;\t\tconfigureHeadlessProperty();\t\tSpringApplicationRunListeners listeners = getRunListeners(args); // -&gt; 해당 함수 추적;\t\tlisteners.starting(bootstrapContext, this.mainApplicationClass);\t\ttry {\t\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\t\t\tConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);\t\t\tconfigureIgnoreBeanInfo(environment);\t\t\tBanner printedBanner = printBanner(environment);\t\t\tcontext = createApplicationContext();\t\t\tcontext.setApplicationStartup(this.applicationStartup);\t\t\tprepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\t\t\trefreshContext(context);\t\t\tafterRefresh(context, applicationArguments);\t\t\tDuration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);\t\t\tif (this.logStartupInfo) {\t\t\t\tnew StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);\t\t\t}\t\t\tlisteners.started(context, timeTakenToStartup);\t\t\tcallRunners(context, applicationArguments);\t\t}    }    private SpringApplicationRunListeners getRunListeners(String[] args) {\t\tClass&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class };\t\treturn new SpringApplicationRunListeners(logger,\t\t\t\tgetSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args), // -&gt; 해당 함수 추적;\t\t\t\tthis.applicationStartup);\t}    private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) {        ClassLoader classLoader = getClassLoader();        // Use names and ensure unique to protect against duplicates        Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));        List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); // -&gt; 해당 함수 추적;        AnnotationAwareOrderComparator.sort(instances);        return instances;    }    private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes,                ClassLoader classLoader, Object[] args, Set&lt;String&gt; names) {        List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size());        for (String name : names) {            try {                Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);                Assert.isAssignable(type, instanceClass);                Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);                T instance = (T) BeanUtils.instantiateClass(constructor, args); // -&gt; 해당 함수 추적;                instances.add(instance);            }            catch (Throwable ex) {                throw new IllegalArgumentException(\"Cannot instantiate \" + type + \" : \" + name, ex);            }        }        return instances;    }    // .....}먼저 SpringApplication 클래스에서 빈 생성 관련으로 추정되는 코드를 확인해봤다.BeanUtils라는 클래스에서 관련 작업을 하는 듯 하여 해당 클래스로 이동해봤다.public abstract class BeanUtils {    // ......    public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args) throws BeanInstantiationException {        Assert.notNull(ctor, \"Constructor must not be null\");        try {            ReflectionUtils.makeAccessible(ctor);            if (KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {                return KotlinDelegate.instantiateClass(ctor, args);            }            else {                Class&lt;?&gt;[] parameterTypes = ctor.getParameterTypes();                Assert.isTrue(args.length &lt;= parameterTypes.length, \"Can't specify more arguments than constructor parameters\");                Object[] argsWithDefaultValues = new Object[args.length];                for (int i = 0 ; i &lt; args.length; i++) {                    if (args[i] == null) {                        Class&lt;?&gt; parameterType = parameterTypes[i];                        argsWithDefaultValues[i] = (parameterType.isPrimitive() ? DEFAULT_TYPE_VALUES.get(parameterType) : null);                    }                    else {                        argsWithDefaultValues[i] = args[i];                    }                }                return ctor.newInstance(argsWithDefaultValues); // -&gt; 해당 함수 추적;            }        }            // ......    }    // ......}public final class Constructor&lt;T&gt; extends Executable {    // ......    public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException,               IllegalArgumentException, InvocationTargetException        {        if (!override) {            Class&lt;?&gt; caller = Reflection.getCallerClass();            checkAccess(caller, clazz, clazz, modifiers);        }        if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)            throw new IllegalArgumentException(\"Cannot reflectively create enum objects\");        ConstructorAccessor ca = constructorAccessor;   // read volatile        if (ca == null) {            ca = acquireConstructorAccessor();        }                @SuppressWarnings(\"unchecked\")        T inst = (T) ca.newInstance(initargs);        return inst;    }}스프링 부트는 리플렉션을 통해 빈을 생성하고 있는 것을 확인할 수 있었다.리플렉션은 힙 영역에 로드된 Class 타입의 객체를 이용해 원하는 클래스의 인스턴스를 생성, 인스턴스의 필드와 메소드를 접근 제어자와 상관 없이 사용할 수 있도록 지원하는 API이다.리플렉션 API를 이용해서 특정 어노테이션이 붙은 요소들을 탐색(@Component, @Service 등등…)하고, 스프링 컨테이너에 관련 빈들을 등록한다.또한 SpringApplication.run() 함수 쪽을 보면 먼저 빈을 탐색, 등록시킨 후에 의존성 주입 작업이 이루어지고 있다는 것을 추측할 수 있었다.이제 빈이 어떻게 생성되는지도 보았고, 스프링의 방식과는 약간 차이가 있지만기본적인 싱글톤이 무엇인지도 살펴보았다.그렇다면 왜 스프링은 기본적으로 싱글톤을 이용해 빈을 생성하는 것일까?빈이 싱글톤인 이유당연히 효율성 때문이다.스프링이 처음 설계됐던 대규모 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십~수백 번씩 브라우저나 여러 시스템으로부터 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다.이런 상황에서 매번 new 연산을 이용해 객체를 생성하는 작업은 매우 값비싼 작업이며, 서버에 엄청난 부하가 걸릴 것이다.이럴 때 스프링 컨테이너에서 미리 정의된 싱글톤 객체를 호출하기만 한다면 훨씬 효율적인 작업 수행이 가능하다.또한 웹에서 주로 쓰이는 HTTP의 무상태성, 비연결성이라는 특징은 싱글톤을 활용하기에 매우 적절한 환경이기도 하다.참고  위키백과, 싱글턴 패턴, https://ko.wikipedia.org/wiki/%EC%8B%B1%EA%B8%80%ED%84%B4_%ED%8C%A8%ED%84%B4  큰돌의 터전, 제대로 이해하는 싱글톤패턴 - 실습#1, https://www.youtube.com/watch?v=3rfbnQYOCFA  큰돌의 터전, 제대로 이해하는 싱글톤패턴 - 실습#2, https://www.youtube.com/watch?v=4Sk9dzXgKwo  느리더라도 꾸준하게, [Java] Reflection 개념 및 사용 방법, https://steady-coding.tistory.com/609  minwest.log, 스프링은 빈을 왜 싱글톤으로 생성할까?, https://velog.io/@minwest/Spring-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%80-%EB%B9%88%EC%9D%84-%EC%99%9C-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9C%BC%EB%A1%9C-%EC%83%9D%EC%84%B1%ED%95%A0%EA%B9%8C"
  },
  
  {
    "title": "스프링 네이티브 메모리 사용량 비교",
    "url": "/blog/posts/%EC%8A%A4%ED%94%84%EB%A7%81_%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C/",
    "categories": "Backend",
    "tags": "",
    "date": "2023-07-18 00:00:00 +0900",
    





    
    "snippet": "메모리 기근운영중인 이미지 관련 웹 서비스가 하나 있는데 서버 메모리가 1GB라 굉장히 빠듯하다.자바 스프링 기반으로 작동하고 있는데, 메모리를 더 효과적으로 사용할 방법이 없을까 싶어서 조사하던 중 스프링 네이티브를 발견하게 되었다.스프링 네이티브란?GraalVM을 활용했으며, 스프링 어플리케이션을 네이티브 이미지로 컴파일하여 기존 JVM에 비해 더...",
    "content": "메모리 기근운영중인 이미지 관련 웹 서비스가 하나 있는데 서버 메모리가 1GB라 굉장히 빠듯하다.자바 스프링 기반으로 작동하고 있는데, 메모리를 더 효과적으로 사용할 방법이 없을까 싶어서 조사하던 중 스프링 네이티브를 발견하게 되었다.스프링 네이티브란?GraalVM을 활용했으며, 스프링 어플리케이션을 네이티브 이미지로 컴파일하여 기존 JVM에 비해 더 작은 메모리 공간과 훨씬 더 빠른 시작 시간으로 실행할 수 있다고 한다.주요 차이점으로는,  애플리케이션의 정적 분석은 진입 main점에서 빌드 시 수행됩니다.  네이티브 이미지가 생성될 때 도달할 수 없는 코드는 제거되며 실행 파일의 일부가 되지 않습니다.  GraalVM은 코드의 동적 요소를 직접 인식하지 않으며 리플렉션, 리소스, 직렬화 및 동적 프록시에 대해 알려야 합니다.  애플리케이션 클래스 경로는 빌드 시 고정되며 변경할 수 없습니다.  지연 클래스 로딩이 없으며 실행 파일에 포함된 모든 항목이 시작 시 메모리에 로드됩니다.  완전히 지원되지 않는 Java 응용 프로그램의 일부 측면에는 몇 가지 제한 사항이 있습니다.등이 있다고 한다. 그렇다면 GraalVM은 무엇일까?GraalVM 이란먼저 만들어진 배경에 대해 살펴보자.기존의 C++로 만들어진 OpenJDK JIT Compiler는 굉장히 오랜 시간 작성된 코드다 보니 해당 소스코드를 능숙하게 다룰 사람을 구하기도 힘들고, 그러다보니 코드 수정 또한 굉장히 어려워서 개선하는 데 한계가 왔다고 한다.그에 따른 대안으로 Java로 구성된 JIT 컴파일러를 만들기로 했고, 인력 충원 및 코드 개선이 훨씬 원활해질 수 있었다고 한다.GraalVM은 기존 JVM에 비해 훨씬 향상된 속도와 리소스 활용 능력을 보여준다고 한다.또한 Ahead-of-TIme Compilation (이하 AOT)를 도입했는데,기존의 인터프리터 실행 환경이 아니라 OS에 맞게 실행 파일을 제작한다.이는 OS에 자바를 미리 구성해야 하는 필요성을 없애주고 굉장히 빠른 실행을 기대할 수 있으나기존 자바의 장점이던 런타임 최적화의 가능성은 사라진다.메모리 테스트일단 내 목적은 메모리 사용량을 줄이는 것이었으니, 한번 테스트를 해보자.테스트 환경은 다음과 같다.plugins {    id 'java'    id 'org.springframework.boot' version '3.0.3'    id 'io.spring.dependency-management' version '1.1.0'    id 'org.graalvm.buildtools.native' version '0.9.17'}group = 'com.coldrain'version = '1' // 버전 명시 안해주면 bootBuildImage 커맨드 시 에러 발생함sourceCompatibility = '17'dependencies {    // spring    implementation 'org.springframework.boot:spring-boot-starter-web'    implementation 'org.springframework.boot:spring-boot-starter-validation'    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'    implementation 'org.springframework.boot:spring-boot-starter-webflux'    // util    compileOnly 'org.projectlombok:lombok'    annotationProcessor 'org.projectlombok:lombok'    implementation 'com.googlecode.json-simple:json-simple:1.1.1'    // db    implementation 'com.h2database:h2'    // jwt    implementation 'io.jsonwebtoken:jjwt:0.9.1'    implementation 'javax.xml.bind:jaxb-api:2.1'    // rest doc    asciidoctorExt 'org.springframework.restdocs:spring-restdocs-asciidoctor'    testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc'    // test    testImplementation 'org.springframework.boot:spring-boot-starter-test'}스프링 부트 3.0.3, 자바 17 버전을 사용했으며  ./gradlew bootBuildImage명령어를 통해 네이티브 이미지를 빌드해봤다.참고로 도커를 미리 설치해 놓아야 한다.소요된 시간은 일반적인 도커 이미지 빌드시간 보다는 훨씬 더 걸린다.정확히 측정은 안해봤는데 체감상 3~4배는 더 걸린 듯 하다.로컬 비교 결과도커 데스크탑을 이용해 메모리 사용량을 확인해 봤다. 참고로 내 서비스의 힙사이즈는 300m, 도커 컨테이너의 메모리는 400m로 제한되어 있다.위의 사진은 평소에 사용하는 이미지의 메모리 사용량이며, 대략 180MB의 메모리를 사용하는 것으로 확인되었다.그렇다면 네이티브 이미지의 메모리 샤용량 결과는 어떻게 나올까?굉장히 큰 폭으로 메모리 사용량이 줄어든 것을 볼 수 있다.VisualVM으로 정확히 어느 부분이 메모리 점유율이 줄어든 것인지 확인하고 싶었지만, 2시간 동안 시도해도 결국 실패해서 일단 이 정도만 확인하고 넘어가기로 했다.또 한 가지 큰 차이가 있다면 부팅 시간이 말도 안되게 빠르다.기존에는 부팅 시간이 대략 3~4초 이내인데, 네이티브 이미지는 0.1 ~ 0.15초 사이로 나타났다.그래서 한 번 운영서버에 띄워보고, 메모리 사용량을 보기로 했다.서버 비교 결과와탭을 이용, 리눅스 서버 모니터링 결과를 가지고 비교해봤다.기존에는 앱을 작동시키고 하루 정도 지나면 전체 서버 메모리 사용량이 85 ~ 90% 사이를 왔다갔다 했다.네이티브는 어떨까?똑같이 하루 정도 지나고 사용량을 확인해보았다. 메모리 점유율이 확연하게 낮아진 것을 확인할 수 있었다.결론나처럼 메모리 기근을 겪는 사람들은 한 번쯤 시도해 보면 좋을 옵션인 듯 하다.그런데 한 가지 신경쓰이는 것은 로그백 관련 에러코드가 처음에 계속 뜨는데, 검색해보니 이건 해당 라이브러리를 관리하는 곳에서 패치를 진행해 줘야 하는 문제라고 한다.다행인 건 로그 기록은 잘 되서 일단 넘어가기로 했다.그리고 이건 어느 쪽 문제인지 모르겠는데, docker-compose volume 매핑이 상당히 까다롭다.기존에는 폴더 하나만 툭 매핑해주면 알아서 잘 찾았는데, 자꾸 db랑 log 파일 접근을 못해서 난감했다.혹시나 매핑이 안되는 사람이 있다면  서버_파일:/workspace/도커에서_접근할_파일이렇게 워크스페이스를 한번 추가해보면 좋을 것 같다.이와 같이 아직 알 수 없는 자잘한 에러들이 분명히 상주하고 있을 테니 하나의 에러조차 치명적인 중요한 서버라면 조금 더 지원 환경이 갖춰진 후에 사용하는 것이 좋을 듯 하다.참고  Spring.io, GraalVM Native Image Support, https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html  NHN Cloud, GraalVM, Spring Native 맛보기, https://meetup.nhncloud.com/posts/273"
  },
  
  {
    "title": "키보드 타이핑 시 일어나는 일들",
    "url": "/blog/posts/%ED%82%A4%EB%B3%B4%EB%93%9C/",
    "categories": "Hardware",
    "tags": "",
    "date": "2023-07-14 00:00:00 +0900",
    





    
    "snippet": "타이핑 시 발생하는 일들키보드를 타이핑 하는 순간 컴퓨터에서는 어떤 일이 일어날까?키를 누르는 순간부터 모니터에 표시되기 까지의 과정이 궁금해서 알아보았다.키캡을 누른 순간먼저 특정 키를 누르면 키보드 아래의 회로에 전류가 흐르고, 마이크로 컨트롤러가 신호를 인식한다.이때 컨트롤러는 키가 눌리거나 떨어질 때 마다 고유 코드를 전송하는데, 이런 특정 키...",
    "content": "타이핑 시 발생하는 일들키보드를 타이핑 하는 순간 컴퓨터에서는 어떤 일이 일어날까?키를 누르는 순간부터 모니터에 표시되기 까지의 과정이 궁금해서 알아보았다.키캡을 누른 순간먼저 특정 키를 누르면 키보드 아래의 회로에 전류가 흐르고, 마이크로 컨트롤러가 신호를 인식한다.이때 컨트롤러는 키가 눌리거나 떨어질 때 마다 고유 코드를 전송하는데, 이런 특정 키의 상태에 따라 다른 고유 코드를 Scan Code 라고 한다.            Key Name      Down Code      Up Code                  Q      0x10      0x90              W      0x11      0x91              E      0x12      0x92              R      0x13      0x93              T      0x14      0x94              Y      0x15      0x95      이런 식으로 별도의 스캔 코드가 존재하며, 이 스캔 코드가 키보드 컨트롤러에 전달된다.키보드 드라이버에서 컨트롤러의 출력 버퍼를 확인 후, 데이터가 존재한다면 이를 ASCII 코드로 변환한다.그렇다면 OS에는 어떻게 이 정보가 전달될까?인터럽트키보드 입력 정보는 인터럽트를 통해서 전달된다.인터럽트는 프로세서에 신호를 보내 현재 작업을 멈추고 다른 일을 실행하게 하는 것이며하드웨어 인터럽트, 소프트웨어 인터럽트, 내부 인터럽트가 존재한다. 가장 쉽게 접할 수 있는 예시로는 윈도우에서 Ctrl + Alt + Del 키를 누르면 뜨는 작업 관리자 창을 생각하면 될 것 같다.키보드 입력이라는 이벤트가 발생하고, 인터럽트가 요청되면 현재 실행중이던 프로그램을 일시 중단한다.그리고 PCB(Process Control Block), PC(Program Counter) 등에 현재의 프로그램 상태 보존 후 인터럽트를 요청한 장치를 식별한다.이 후 요청과 관련된 작업이 시작되는데 만약 우선순위가 더 높은 인터럽트 발생 시 키보드 입력을 중지하고 해당 인터럽트 처리가 시작된다.이때 인터럽트 플래그(IF)를 0으로 하면 다른 인터럽트의 발생을 방지할 수 있다.작업이 끝나면 인터럽트 발생 전 원래 작업중이던 프로그램의 실행을 재개한다.디스플레이이제 입력된 키 값을 모니터에 표시해야 한다.화면에 표시할 이미지, 텍스트, 그래픽 요소 등을 생성하고 조합하는 작업은 보통 GPU에서 실행되며안티앨리어싱, 래스터화등의 작업을 거친 후 각 픽셀의 색상 정보를 저장하는 역할인 프레임 버퍼 메모리 영역에 저장된다.이제 이 변환된 데이터들을 모니터로 전송하면 해당 정보를 바탕으로 화면에 이미지, 텍스트를 표시하게 된다.참고  피누.log, 키보드를 누르면 어떤 일이 발생할까?, https://velog.io/@litien/키보드를-누르면-어떤-일이-발생할까  bss 영역, 64비트 멀티코어 OS[10] - 1. 키보드 컨트롤러의 구조와 기능과 키보드 컨트롤러 제어,https://sean.tistory.com/151  bss 영역, 64비트 멀티코어 OS[10] - 2. 스캔 코드와 간단한 셸, https://sean.tistory.com/152  IT위키, 인터럽트, https://itwiki.kr/w/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8  위키백과, 래스터 그래픽스, https://ko.wikipedia.org/wiki/%EB%9E%98%EC%8A%A4%ED%84%B0_%EA%B7%B8%EB%9E%98%ED%94%BD%EC%8A%A4  SKKU CE STUDY, 컴퓨터 그래픽스(1), https://trpark.tistory.com/entry/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B7%B8%EB%9E%98%ED%94%BD%EC%8A%A41  위키백과, 프레임버퍼, https://ko.wikipedia.org/wiki/%ED%94%84%EB%A0%88%EC%9E%84%EB%B2%84%ED%8D%BC"
  },
  
  {
    "title": "재시도 전략",
    "url": "/blog/posts/%EC%9E%AC%EC%8B%9C%EB%8F%84_%EC%A0%84%EB%9E%B5/",
    "categories": "Backend",
    "tags": "",
    "date": "2023-07-13 00:00:00 +0900",
    





    
    "snippet": "API 요청과 재시도API 요청에 실패하면 어떻게 대응하는 것이 좋을까?  될때까지 쏘기  한 10분 있다가 다시 요청하기  그냥 멍때리기전부 다 좋은 방법은 아닌 것 같다.1번 방법 사용 시 API를 제공하는 서버에 지속적으로 부하를 걸어서 장애 복구에 차질이 생기게 할 수 있다. 또한 내 서버도 굉장히 많은 리소스를 낭비하게 된다.2번 방안은 몇 ...",
    "content": "API 요청과 재시도API 요청에 실패하면 어떻게 대응하는 것이 좋을까?  될때까지 쏘기  한 10분 있다가 다시 요청하기  그냥 멍때리기전부 다 좋은 방법은 아닌 것 같다.1번 방법 사용 시 API를 제공하는 서버에 지속적으로 부하를 걸어서 장애 복구에 차질이 생기게 할 수 있다. 또한 내 서버도 굉장히 많은 리소스를 낭비하게 된다.2번 방안은 몇 분 후에 장애 복구될지 누가 알 것인가?3번으로 대응 시 유저 다 나간다.이런 상황을 대비해서 나온 이론들과 관련 라이브러리들이 존재했다.내가 작성한 코드는 비록 외부 상황의 문제더라도 결국 내 책임이니 다양한 장애 상황을 대비해서 공부를 해놓으면 좋을 것 같다는 생각에 글을 작성하게 되었다.자꾸 무슨 일 난다고 조상님이나 종교 찾지 말자. 그분들 바쁘다.회로 차단기 (Circuit Breaker)전자 회로 실습을 하던 때를 상상해보자.우리는 보통 저항 -&gt; LED 소자 순으로 회로를 구성해 과부하를 방지한다.동일한 전압에서 저항값이 낮을수록 전류가 높아지기 때문인데 회로의 노후화나 접촉 불량 등으로 저항을 거치지 않고 LED로 전력이 바로 공급되는 상황을 보통 단락, 쇼트가 났다고 말한다.만약 과전류가 흐른다면 회로에 전력 공급을 중단해야 하는데,위 사진과 같이 회로를 개방시켜 전류의 흐름을 막은 상태를 Open된 상태라고 한다. 스위치가 열려있다고 생각하면 편하다.그러면 반대로 스위치를 눌러서 회로가 연결된 상태는 Closed 라고 한다.이런 상황을 사람이 계속 감시할 수는 없으니 특정 상태를 감지해서 회로를 정지시키는, 두꺼비집과 같은 장치들을 회로 차단기라고 부른다.갑자기 왜 회로 이야기를 했나면, 여기서 아이디어를 얻어 나온 디자인 패턴이 서킷 브레이커 패턴이기 때문이다.서킷 브레이커 패턴회로를 차단하던 과정을 코드로 옮긴 것이 서킷 브레이커 패턴이다.해당 패턴에는 3가지의 상태가 존재하는데, 위에서 언급한 Open, Closed 상태를 떠올리면 이해가 쉽다.  CLOSED          요청의 실패율이 정해 놓은 임계치보다 낮은 정상적인 상태      스위치가 닫힌 회로, 전류 잘 통하는 중        OPEN          요청의 실패율이 정해 놓은 임계치를 넘어선 상태      요청을 전송하지 않고 바로 에러를 발생      스위치가 열린 회로, 전류 공급 차단        HALF_OPEN          OPEN 상태에서 주기적으로 요청을 전송하여 응답을 확인하는 상태      성공하면 CLOSED 상태로 전환, 실패하면 OPEN 상태를 유지      스위치 열까 다시 닫을까 고민중인 상황      장애 발생 기준은 크게 기준치보다 느린 응답(slow call), 실패한 응답(failure call) 2가지가 존재한다고 하며,해당 값들이 임계치를 넘을 경우 OPEN 상태로 전환하는 방식이다.이러한 방식은 빠른 실패 및 고객 응답, 장애 발생 서비스의 부하 감소 등의 효과를 기대할 수 있다.관련 라이브러리로는 Resilience4J, Armeria, Hystrix 등이 존재하며 Hystrix는 지원을 중단한 상태라고 하니 참고하자.결론최근에 어떤 문제만 발생하면 종교에 기댄다는 지인 이야기를 들었다.몇날 며칠동안 자신의 신을 찾아 울부짖으면 어느새 해결이 되어 있다는 이야기였는데,문제를 해결해 준 것은 기도하던 신이었을까, 울음소리를 듣던 주변 사람들의 도움이었을까.항상 성공하는 요청을 신뢰하며 실패할 일 따윈 없다고 생각하면,믿음이 깨지는 그 순간에는 스스로 대처할 힘이 있을까.결론은 에러 상황 대비를 잘하자. 뭔 일이 언제 날 지 다 예측 가능하면 미아리고개 점집들은 진작 망했다. 다만 불확실한 미래가 존재한다는 사실은 알고 있으니, 준비 정도는 해보면 좋지 않을까.참고  망나니개발자, [디자인패턴] 서킷 브레이커 패턴(Circuit Breaker Pattern)의 필요성 및 동작 원리, https://mangkyu.tistory.com/261  Line Engineering, Armeria의 서킷 브레이커 사용해 보기, https://engineering.linecorp.com/ko/blog/try-armeria-circuit-breaker"
  },
  
  {
    "title": "자바 버전별 릴리즈",
    "url": "/blog/posts/%EC%9E%90%EB%B0%94/",
    "categories": "Language",
    "tags": "",
    "date": "2023-07-12 00:00:00 +0900",
    





    
    "snippet": "언어의 성장 방향문득 자바의 개발 방향은 어디로 향하고 있는 것인지 궁금해졌다.그래서 각 버전별로 릴리즈 노트를 찾아보았고, 다 정리하기엔 너무 많아서 일부 목록만 발췌한 후 어떤 패치들이 이루어졌는지 살펴보려 한다.버전별 릴리즈Java 11  HTTP 클라이언트 API를 표준화  새 Collection.toArray(IntFunction) 기본 메서...",
    "content": "언어의 성장 방향문득 자바의 개발 방향은 어디로 향하고 있는 것인지 궁금해졌다.그래서 각 버전별로 릴리즈 노트를 찾아보았고, 다 정리하기엔 너무 많아서 일부 목록만 발췌한 후 어떤 패치들이 이루어졌는지 살펴보려 한다.버전별 릴리즈Java 11  HTTP 클라이언트 API를 표준화  새 Collection.toArray(IntFunction) 기본 메서드  Lambda 매개변수에 대한 로컬 변수 구문 (var)  컴파일러 스레드의 지연 할당 (-XX:+UseDynamicNumberOfCompilerThreads)  ZGC 확장 가능한 저지연 가비지 수집기  무작동 가비지 수집기 Epsilon GC, 메모리 할당만 처리하고 메모리 회수 메커니즘을 구현 X  jvmti를 통한 낮은 오버헤드 힙 프로파일링코드 레벨은 편의성 기능들이 패치되었고,인프라는 주로 성능 관련 개선이 많이 이루어진 것을 확인할 수 있다. Epsilon GC는 특이해서 한번 찾아봤는데  실제 내 어플리케이션이 얼마나 메모리를 사용하는 지에 대한 임계치나 어플리케이션 퍼포먼스 등을 보다 정확하게 측정할 수 있다고 한다. 임베디드 환경에서 유용할 수 있다는 글도 봤는데 왜 그런지는 잘 모르겠다. 만약 신호등 같은 교통 제어 시스템에서 OOM나면 대참사 아닌가??Java 15  CharSequence에 isEmpty 기본 메서드 추가  유니코드 13.0 지원  Nashorn JavaScript 엔진 제거  사용되지 않음 -XXUseAdaptiveGCBoundaryNashorn JavaScript 엔진 제거가 눈에 띈다. 왜 없앴을까? 코드 간 섞임을 방지해 경계를 명확히 하려는 의도일까?Java 16  Stream.toList() 메서드 추가  record 클래스 추가  ZGC 동시 스택 처리  Elastic Metaspace엘라스틱 메타스페이스는 VM 내부 메타스페이스 및 클래스 공간 구현을 정밀 검사해서 클래스 메타데이터에 사용되는 메모리를 줄여주는 기술이라고 한다.record 클래스는 들어보기만 해서 찾아봤는데, 순수하게 데이터를 보유하기 위한 특수 클래스라고 한다.생긴게 클래스가 아니라 함수같기도 한데, 부가적인 코드를 굉장히 줄여주는 것 같다. 예를 들자면,public class Person {    private final String name;    private final int age;        public Person(String name, int age) {        this.name = name;        this.age = age;    }        public String getName() {        return name;    }        public int getAge() {        return age;    }}위와 같은 코드가public record Person(String name, int age) {}다음과 같이 간결해 진다고 한다. 여기서 단순히 데이터 클래스로만 사용하지 않고,@RestControllerpublic record HelloController(HelloService helloService) {    @GetMapping(\"/\")    public void sampleRecord() {        helloService.hello();    }}이런 식으로도 사용이 가능하다고 한다. 뭔가 코틀린 코드 같다.Java 17  Sealed class 추가  macOS의 ARM 얼리 액세스 사용 가능  새로운 macOS 렌더링 파이프라인  macOS에서 UserDefinedFileAttributeView에 대한 지원 추가왜 이렇게 맥 관련 패치가 많나 확인해보니 17 버전이 21년 9월에 출시되었는데, 비슷한 시점에 애플 신제품들이 많이 출시되었다. 아마 그에 맞게 여러가지 패치를 한게 아닌가 싶다.Sealed 클래스는 상속하거나 구현할 클래스를 지정해두고, 해당 클래스들만 상속/구현이 가능하도록 제한하는 기능이라고 한다.다음과 같이 사용한다고 한다.public sealed class Character permits Wizard, Warrior {}public sealed class Wizard extends Character permits A, B {    }// non-sealed는 누구나 상속 가능public non-sealed class Warrior extends Character {}public final class A extends Wizard {}public final class B extends Wizard {}// 상속 불가능, 에러public class BadDog extends Wizard {} // 상속 가능public class GoodDog extends Warrior {} Java 18  UTF-8 기본값 지정  최소 정적 웹 서버 jwebserver 추가  ZGC, SerialGC, ParallelGC 문자열 중복 제거 지원  최대 512MB의 G1 힙 영역 허용  지원 중단된 Thread.stop()UTF-8이 기본값으로 지정되며 범용성이 높아졌다.jwebserver라는 테스트 용도의 가벼운 정적 웹 서버도 추가되었으며, G1 가바지 컬렉터의 힙 사이즈 허용 영역이 늘어났다. 큰 규모의 서버에 대비해서 이루어진 패치가 아닐까 싶다.Java 20  스위치용 패턴 매칭(4차 프리뷰)  Foreign Function &amp; Memory API (2차 프리뷰)  벡터 API(5차 인큐베이터)  Scoped Values (인큐베이터)  Structured Concurrency API (2차 인큐베이터)  가상 스레드(2차 프리뷰)  유니코드 15.0 지원19를 생략한 이유는 대부분의 주요 기능들이 20까지 이어지는 프리뷰 기능들이라 그렇다.지금까지 프리뷰 기능은 기록하지 않았는데 20에서는 워낙 요즘 핫한 아이들이 많아서 적어야 할 것 같다.먼저 스위치 구문이 개선되고 있다. 기존의 스위치 문은 약간 노가다성이 짙었는데, 다음과 같이 향상되고 있다.// 기존 방식, 참 길다switch (day) {    case MONDAY:        break;    case TUESDAY:        System.out.println(1);        break;    case WEDNESDAY:        System.out.println(1);        break;    case THURSDAY:        break;    case FRIDAY:        break;    case SATURDAY:        System.out.println(1);        break;    case SUNDAY:        System.out.println(1);        break;    default:        break;   }// 개선되는 방식switch (day) {    case MONDAY, TUESDAY, WEDNESDAY\t-&gt; System.out.println(1);    case THURSDAY\t\t\t\t-&gt; System.out.println(2);    case FRIDAY, SATURDAY\t\t-&gt; System.out.println(3);    case SUNDAY\t\t\t\t-&gt; System.out.println(4);}// 변수 대입도 가능int value = switch (day) {    case MONDAY, TUESDAY, WEDNESDAY\t-&gt; 1;    case THURSDAY\t\t\t\t-&gt; 2;    case FRIDAY, SATURDAY\t\t-&gt; 3;    case SUNDAY\t\t\t\t-&gt; 4;};메모리 API는 힙 영역이 아닌 네이티브 메모리에 접근하기 위해 나온 기술로 안전하고 효율적으로 네이티브 메모리에 액세스하도록 도와준다고 한다.벡터 API는 벡터 계산을 표현하는 API를 도입하여 동등한 스칼라 계산보다 우수한 성능을 달성한다고 하며,Scoped Value는 스레드 내부 및 스레드 간에 변경 불가능한 데이터를 공유할 수 있도록 한다고 한다Structured Concurrency API는 다중 스레드 코드를 관리하기 위한 API라고 한다.아래의 코드를 확인해보자.Future&lt;Shelter&gt; shelter;Future&lt;List&lt;Dog&gt;&gt; dogs;try (ExecutorService executorService = Executors.newFixedThreadPool(3)) {    shelter = executorService.submit(this::getShelter); // 정상 처리됨    dogs = executorService.submit(this::getDogs); // 작업 실패함        Shelter theShelter = shelter.get(); // 실패 여부에 대해 전혀 모름    List&lt;Dog&gt; theDogs = dogs.get();  // 실패한 상태, 예외 던짐    Response response = new Response(theShelter, theDogs);} catch (ExecutionException | InterruptedException e) {    throw new RuntimeException(e);}기존의 여러 스레드를 활용한 작업에서는 특정 작업의 실패가 전파되지 않으며 리소스가 낭비된다.Structured Concurrency API에서는 이러한 문제를 해결한다.record Shelter(String name) { }record Dog(String name) { }record Response(Shelter shelter, List&lt;Dog&gt; dogs) { }try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {    Future&lt;Shelter&gt; shelter = scope.fork(this::getShelter);    Future&lt;List&lt;Dog&gt;&gt; dogs = scope.fork(this::getDogs);    scope.join();    Response response = new Response(shelter.resultNow(), dogs.resultNow());    // ...}ShutdownOnFailure()는 문제가 발생할 경우 하위 작업을 종료해서 리소스 낭비를 방지한다.그 외에도 ShutdownOnSuccess(), throwIfFailed(), joinUntil()등을 통해 불필요한 작업을 방지하고 효과적인 코드 작성이 가능하며,다중 스레드 코드를 마치 동기식처럼 쉽게 작성할 수 있다.가상 스레드는 기존 자바의 스레드를 개선하기 위해 등장했다.자바의 스레드는 OS의 스레드를 이용하는 방식인데 이를 효율적으로 이용하기 위해 스레드풀을 만들어 사용한다.제한적인 갯수의 스레드풀 내에서 요청당 하나의 스레드가 배정되고 작업을 대기 및 처리하는 과정에서 많은 리소스가 수반된다.이를 해결하기 위해 리액티브 프로그래밍(Webflux)이 발전했지만 코드의 숙련도, 기존 코드와의 호환성 등의 문제가 있었다.이를 해결하기 위해 가상 스레드가 탄생하게 되었다.JVM 자체적으로 가상 스레드를 OS의 스레드와 매칭시켜주면서 기존 스레드 방식의 이점은 취하되효율적인 자원 사용이 가능해졌다.결론뻔한 결론이지만 코드 작성은 편하게, 성능은 좋아지게 발전하고 있는 것 같다.한 가지 든 생각이 있다면 메모리 여분을 최대한 확보하고 효율적으로 활용하려는 시도들이 많이 보이는 것 같다.요즘 스프링 진영에서는 GraalVM 등을 활용한 네이티브 이미지로 굉장히 많은 메모리를 절약할 수 있는 방식들을 고안했고자바에서는 가비지 컬렉터들의 지속적인 개선, 가상 스레드, 메모리 API와 같은 시도들을 통해 성능 및 메모리 최적화를 진행하는 것을 확인할 수 있었다.둘의 시너지가 잘 맞아보길 기대한다.참고  Oracle, JDK 11 Release Notes, https://www.oracle.com/java/technologies/javase/11-relnote-issues.html  Oracle, JDK 15 Release Notes, https://www.oracle.com/java/technologies/javase/15-relnote-issues.html  Oracle, JDK 16 Release Notes, https://www.oracle.com/java/technologies/javase/16-relnote-issues.html  Oracle, JDK 17 Release Notes, https://www.oracle.com/java/technologies/javase/17-relnote-issues.html  Oracle, JDK 18 Release Notes, https://www.oracle.com/java/technologies/javase/18-relnote-issues.html  Oracle, JDK 19 Release Notes, https://www.oracle.com/java/technologies/javase/19-relnote-issues.html  Oracle, JDK 20 Release Notes, https://www.oracle.com/java/technologies/javase/20-relnote-issues.html  baeldung, Foreign Memory Access API in Java 14, https://www.baeldung.com/java-foreign-memory-access  baeldung, Structured Concurrency in Java 19, https://www.baeldung.com/java-structured-concurrency  congcoding, [Java 14] 개선된 switch 문(Enhanced Switch Expressions), https://congcoding.tistory.com/73  MarrRang Dev Blog, [Java] Sealed Class, https://marrrang.tistory.com/82  코딩스타트, Java - jdk 14 record(레코드) 란?! Data class(데이터 클래스), https://coding-start.tistory.com/355  HYPEBEAST, 9월 예정, ‘애플 이벤트’에서는 어떤 신제품들이 공개될까?, https://hypebeast.kr/2021/8/apple-event-rumor-new-iphone-macbook-pro-airpods-ipad  Javarevisited, How to Use Java 19 Virtual Threads, https://medium.com/javarevisited/how-to-use-java-19-virtual-threads-c16a32bad5f7  findstar, Virtual Thread란 무엇일까? (1), https://findstar.pe.kr/2023/04/17/java-virtual-threads-1/"
  },
  
  {
    "title": "포인터는 왜 필요할까",
    "url": "/blog/posts/%ED%8F%AC%EC%9D%B8%ED%84%B0/",
    "categories": "Language",
    "tags": "",
    "date": "2023-07-11 00:00:00 +0900",
    





    
    "snippet": "뒤바뀐 인과관계포인터에 대해 검색하던 도중 내가 궁금한 요소가 해결되지 않았다.‘포인터 탄생 배경’ 등에 대해 검색을 해 보면 대부분의 검색 결과가포인터가 ‘필요한 이유’가 아닌 포인터가 등장해서 얻은 이점과 같은 ‘결과’에 대한 서술이 많았다.원래 전공이 하드웨어에 가까운 학과라 포인터의 당위성에 대해 부분적으로 어렴풋이 알고 있었는데, 이번 기회에...",
    "content": "뒤바뀐 인과관계포인터에 대해 검색하던 도중 내가 궁금한 요소가 해결되지 않았다.‘포인터 탄생 배경’ 등에 대해 검색을 해 보면 대부분의 검색 결과가포인터가 ‘필요한 이유’가 아닌 포인터가 등장해서 얻은 이점과 같은 ‘결과’에 대한 서술이 많았다.원래 전공이 하드웨어에 가까운 학과라 포인터의 당위성에 대해 부분적으로 어렴풋이 알고 있었는데, 이번 기회에 확실히 더 찾아봐서 정리를 해 보려고 한다.포인터란?  C언어에서 포인터란 메모리의 주소값을 저장하는 변수이며, 포인터 변수라고도 부릅니다.char형 변수가 문자를 저장하고, int형 변수가 정수를 저장하는 것처럼 포인터는 주소값을 저장합니다. -TCP 스쿨포인터는 주소값을 저장하는 변수이다. 예를 들어서,char *arr = malloc(sizeof(char) * 10);이렇게 포인터 변수를 선언한다면 ‘변수’는 스택에 저장되고, ‘변수를 가리키는 주소(데이터)’는 힙에 저장된다.포인터 사용 시 메모리 주소를 참조하기 때문에 배열과 같은 연속된 데이터에 접근과 조작이 용이하고,동적 할당된 메모리 영역(힙 영역)에 접근과 조작이 용이하다고 한다.그런데 갑자기 궁금해진다. 계속 나오는 단어가 주소 인데, 왜 주소를 참조해야 할까?결국 이 의문을 풀어야 포인터를 왜 사용하는 지 알 것 같은데, 소프트웨어 레벨에서는 명쾌한 답을 찾기 힘들다.한 단계 더 아래로 내려가보자.DRAM의 구조우리가 흔히 컴퓨터에 장착하는 메모리, 주기억장치는 DRAM이다.DRAM은 캐패시터를 저장소자로 사용하고 전하 누수, 지속적 refresh 필요, 가격 저렴, 속도 느림 이런 특징들이 있다고 하지만우리의 관심사는 아니다.아주 심플하게 이것만 기억해보자.  전하 없음 -&gt; 0, 전하 있음 -&gt; 1  1비트의 데이터 저장 가능 -&gt; 기억장소(cell)데이터 접근 과정해당 그림 우측의 네모네모한 아이들이 위에서 말한 데이터 저장 장소, 셀이다.현재 64개의 셀이 존재하고, 6개의 주소선이 이어져 있는 것을 볼 수 있다.그림을 보고 감이 왔을 수 있는데, 주소를 활용하는 이유는 훨씬 효율적이기 때문이다.설명을 이어 하자면, 행과 열을 선택할 수 있게 하는 주소선이 3개씩 나뉘어져 디코더 등의 IC 칩으로 입력된다.Row Address Buffer로 들어간 3개의 신호는 셀의 행, 즉 8개의 가로선 중 하나를 특정할 수 있게 한다. (2^3 = 8)그러면 특정된 셀의 행의 데이터는 Sense Amp에 올라가고, Column Address Buffer의 신호를 이용해 8개의 셀 중 1개를 선정할 수 있게 된다.주소를 사용하지 않는다면?위에 언급한 과정을 더 간략화 한 그림이다.주소 개념을 사용한 경우 위와 같이 6개의 신호선만으로 다양한 셀에 접근할 수 있었다.만약 주소를 사용하지 않고 저 셀마다 데이터 선을 1대 1로 연결할 경우, 64개의 선이 연결되어야 한다. 점점 차이가 얼마나 벌어지는지 비교를 해보자.  주소선 6 == 단일 연결 64 (2^3 * 2^3)아직은 할만하다. 만약 1,024 개의 셀을 사용한다고 하면?  주소선 10 == 단일 연결 1,024 (2^5 * 2^5)슬슬 버겁다. 만약 40억 개의 셀을 사용한다고 하면?  주소선 32 == 단일 연결 4,294,967,296 (2^16 * 2^16)말도 안되게 차이나는 것을 볼수 있다. 결국 효율을 위해서 주소 개념을 사용하는 것이고,포인터는 그 개념을 적극적으로 활용할 수 있는 도구였다.참고  딴딴’s 반도체사관학교, 한 눈에 보는 DRAM 동작원리,  https://sshmyb.tistory.com/174  TCP school, 메모리의 구조, http://www.tcpschool.com/c/c_memory_structure  Computer Science, Dynamic Random Access Memory (DRAM). Part 2: Read and Write Cycles, https://www.youtube.com/watch?v=x3jGqOrXXc8  st-lab, 메모리 구조 [Memory Structure], https://st-lab.tistory.com/198"
  },
  
  {
    "title": "데이터베이스 인덱스",
    "url": "/blog/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%B8%EB%8D%B1%EC%8A%A4/",
    "categories": "DB",
    "tags": "",
    "date": "2023-03-07 00:00:00 +0900",
    





    
    "snippet": "Index소개인덱스는 테이블의 컬럼 색인화, 책의 목차 기능을 제공한다.데이터 정렬 후 별도의 메모리 공간에 저장하는데, 이 형태는 컬럼 값(key), 물리 주소(value)로 설정된다.목적            first_name      age                  kim      15              lee      30      ...",
    "content": "Index소개인덱스는 테이블의 컬럼 색인화, 책의 목차 기능을 제공한다.데이터 정렬 후 별도의 메모리 공간에 저장하는데, 이 형태는 컬럼 값(key), 물리 주소(value)로 설정된다.목적            first_name      age                  kim      15              lee      30              park      25              lee      20              park      10      다음과 같은 자료가 있다고 가정해보자. 만약 인덱스가 없다면 다음과 같은 쿼리를 실행했을 경우데이터베이스를 모두 스캔해야 한다.SELECT first_name FROM 'TABLE' WHERE age = 20하지만 인덱스가 있다면, 인덱스 테이블에서 해당 자료의 위치를 빠르게 찾아결과를 빠르게 탐색할 수 있다. 인덱스 존재 유무에 따른 속도 테스트를 진행해 보았다.코드는 다음과 같다.Entity@Table(indexes = {@Index(name = \"test_index\",columnList = \"first_name\")}) // 해당 어노테이션을 기입, 제거하는 방식으로 진행했다. @Getter@NoArgsConstructor@AllArgsConstructor@Entity@Builderpublic class TestEntity {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    @Column(name = \"first_name\")    private String firstName;}Test Code@SpringBootTest@TestInstance(TestInstance.Lifecycle.PER_CLASS)public class DBTest {    @Autowired    private TestRepository testRepository;    @BeforeAll    void init(){        for(long i = 0; i &lt; 1000000; i++){            TestEntity test = TestEntity.builder()                    .firstName(\"kim\" + i)                    .build();            testRepository.save(test);        }    }    @AfterAll    void release(){        testRepository.deleteAll();    }    @ParameterizedTest    @ValueSource(ints = {1,2,3,4,5,6,7,8,9,10})    void test(int count){        testRepository.findByFirstName(\"kim\" + count);    }}결과는 다음과 같다.인덱스 존재인덱스 없음인덱스의 존재 유무에 따라 차이가 확연한 것을 볼 수 있다.장점  검색 속도 및 성능 향상(조건부)인덱스는 정렬된 형태의 데이터를 가지기 때문에, 인덱스를 통해 테이블 검색 속도가 향상되고이는 전반적인 어플리케이션의 성능 향상으로 이어질 수 있다. 하지만 반드시 인덱스를 설정한다고모든 프로그램의 성능이 좋아지리라는 보장은 없다.단점  잦은 데이터 수정 시 성능 저하테이블의 데이터를 수정 시 인덱스의 내용도 수정되어야 한다.이는 삽입 및 수정이 빈번한 경우에는 오히려 더 큰 부하로 작용할 수 있다.  데이터 제거 시 인덱스는 제거되지 않음테이블에서 데이터가 삭제되어도, 인덱스 테이블에서는 ‘사용하지 않음’ 처리 후 데이터를 남겨둔다고 한다.이는 실제 데이터에 비해 인덱스 과도하게 커지는 문제점이 발생할 수 있다.  검색 성능 저하인덱스를 잘못된 컬럼에 걸어 놓으면 오히려 성능이 저하될 수 있다.나이, 성별과 같은 값의 범위가 좁은 경우에는 인덱스를 확인해도 어차피 다시 많은 데이터를 조회해야 하기 때문이다.사용하면 좋은 경우데이터의 수정 및 삭제가 자주 발생하지 않으며,검색과 같은 조회가 잦고, 데이터의 중복도가 낮은 컬럼을 인덱스로 사용하면 큰 효과를 볼 수 있다.내부 구현key, value로 이루어져 있기 때문에 해시테이블 같은 자료구조를 떠올리기 쉬우나, 해시테이블의 특성상 등호(==) 연산에만 최적화 되어있고, 부등호(&gt;, &lt;) 연산에는 취약하므로 잘 사용되지 않는다고 한다.실제 구현은 검색 범위를 좁히기도 쉽고, 범위 검색에도 좋은 B+ 트리를 사용한다고 한다.B+ TreeB+ 트리는 오직 leaf node에만 데이터를 저장한다.leaf node가 아닌 node에서는 자식의 포인터만 저장하고,특정 key 에 접근하기 위해서는 leaf node까지 가야 한다.그리고 leaf node끼리는 Linked list로 연결되어 있는데, 이를 통해효율적인 순차 검색, 부등호 연산이 가능해지게 된다.참고  코딩애플, index가 뭔지 설명해보세요, https://www.youtube.com/watch?v=iNvYsGKelYs"
  }
  
]

